<<echo = FALSE, results = "hide", message = FALSE>>=
source("../knitr-settings.R")
library(animaker)

# Override width and height because it usually makes more sense
# to use wide plots insted of square ones.
opts_chunk$set(fig.width = 5, out.width = "5in")
@

\chapter{Animation Sequencing}
\label{chap:animseq}

This chapter is divided into two sections. The first section describes
the \pkg{animaker} package for generating descriptions of animation
sequences. An animation sequence is composed by combining atomic
animations in series to create sequence animations or in parallel to
create track animations. Functions are provided for manipulating
animation sequences, generating timing schemes from animation
sequences, and producing diagrams to visualise animation sequences.

The second section in this chapter describes how animation sequences
can be applied in a web browser using the \pkg{TimingManager} library
in \proglang{JavaScript}. It is not concerned with creation or
modification of animation timing information, and delegates those
tasks to \R{} via the \pkg{animaker} package. Primarily
\pkg{TimingManager} is focused on assigning actions to existing
animations, then playing animation sequences using either a
declarative or frame-based approach.

\section{Describing Animation Sequences}
\label{sec:descseq}

\subsection{Introduction}

Several \R{} packages exist for generating animations in \R{}. For
example, the \pkg{animation} package provides convenience functions
for generating an animation, in a wide variety of formats, from a
series of static frames, where the frames are drawn in a loop using
normal \R{} graphics functions. Several other packages provide a more
declarative approach, allowing individual animation actions to be
specified in terms of a start value and end value (plus a start time
and end time). For example, the \pkg{animatoR} package
\autocite{Ble11} provides functions for generating static frames from
a declarative animation and the \gridSVG{} package and the
\pkg{SVGAnnotation} package both provide functions for adding
declarative animation information to an \R{} plot in an SVG format
(for viewing on the web).

One of the difficulties that arises when attempting to generate an
animation sequence with these packages is the coordination of multiple
animation actions. For example, something as simple as ensuring that
action A follows action B can become complicated to specify and
difficult to maintain if those two actions are part of a larger
collection of animation actions that also need to be run either in
sequence or in parallel.

This section describes an \R{} package called \pkg{animaker}
\autocite{MurPot12} that can be used to generate a description of an
animation sequence. The description is completely abstract and only
focuses on a specification of when animation actions should
occur. Animation actions are only represented by a label and no
actions are actually carried out, though there are functions to
generate a timing information for the animation. There are also
functions for drawing diagrams (including animated diagrams) to
visualise the animation sequence.

\subsection{Atomic animations}

The fundamental component of an animation sequence is an \emph{atomic
  animation}, which simply consists of a \code{start} value and a
\code{durn} (duration). It is also possible to specify a \code{label},
but this will be automatically generated by default. An atomic
animation is generated using the \code{atomic()} function; both the
\code{start} and \code{durn} default to zero.

<<showAtomic>>=
atomic()
@

The following code shows a more realistic example, where an atomic
animation is generated with a duration of 2 seconds. There is a
\code{plot()} method for atomic animations which draws a diagram of
the animation sequence represented by the atomic animation (see
\autoref{fig:showPlotAtomic}).

<<showPlotAtomic, echo = -3, fig.height = 2, out.height = "2in", fig.cap = "A diagram of an atomic animation with duration of 2 seconds.">>=
atmc <- atomic(durn = 2)
atmc
plot(atmc)
@

The \code{start} argument can be used to delay the start of the
animation, as shown in the code below and in
\autoref{fig:startAndDuration}.

<<startAndDuration, echo = -3, fig.height = 2, out.height = "2in", fig.cap = "A diagram of an atomic animation with a delay of 1 second (and a duration of 2 seconds).">>=
delay <- atomic(start = 1, durn = 2)
delay
plot(delay)
@

Note that this system only uses the start and duration times to
determine when an animation action will be \emph{started}. There is no
requirement that the animation action actually plays for exactly the
prescribed duration. It is expected that the duration will be passed
to the animation action and that some actions will take note of the
duration and respond accordingly, but it is also acknowledged that the
animation action may completely ignore the duration information.

\subsection{Container animations}

A \emph{container animation} is a collection of animations. In the
simplest case, a container is a collection of atomic animations, but
it is also possible to have a collection of container animations (or a
mixture of both).

There are two sorts of containers, \emph{sequence animations} and
\emph{track animations}. A sequence animation plays a collection of
animations one after the other. A track animation plays a collection
of animations simultaneously.

To demonstrate these ideas, we first create three atomic animations:
one lasting 1 second, one lasting 2 seconds, and one lasting 3
seconds.

<<firstSeqAnimDefs>>=
a <- atomic(durn = 1)
b <- atomic(durn = 2)
c <- atomic(durn = 3)
@

The \code{vec()} function can be used to create a sequence animation
by running these animations sequentially (see
\autoref{fig:firstSeqAnim}).

<<firstSeqAnim, echo = -2, fig.height = 2, out.height = "2in", fig.cap = "A sequence animation consisting of three atomic animations.">>=
v <- vec(a, b, c)
plot(v)
@

The \code{trac()} function can be used to create a track animation by
running these animations in parallel (see
\autoref{fig:firstTrackAnim}).

<<firstTrackAnim, echo = -2, out.height = "2.5in", out.width = NULL, fig.cap = "A track animation consisting of three atomic animations.">>=
t <- trac(a, b, c)
plot(t)
@

The contents of a container can be another container. For example, the
following code produces an animation sequence consisting of a track
animation followed by a sequence animation (see
\autoref{fig:containerEx}).

<<containerEx, echo = -2, out.height = "2.5in", out.width = NULL, fig.cap = "A sequence animation consisting of a track animation followed by a sequence animation.">>=
container <- vec(t, v)
plot(container)
@

\subsection{Controlling the start and duration of containers}

A container animation may have its own \code{start}, which delays the
entire collection of animations (see
\autoref{fig:containerWithDelay}).

<<containerWithDelay, echo = -2, fig.height = 2, out.height = "2in", fig.cap = "A sequence animation (consisting of three atomic animations) with a delayed start.">>=
vDelay <- vec(a, b, c, start = 1)
plot(vDelay)
@

\subsection{Controlling the start and duration of container content}

By default, the \code{durn} of a container animation is calculated
from the animations within the container, but this may be overridden
(see \autoref{fig:contentDuration}).

<<contentDuration, echo = -2, fig.height = 2, out.height = "2in", fig.cap = "A sequence animation (consisting of three atomic animations) with a delayed start and an explicit duration.">>=
vDurn <- vec(a, b, c, start = 1, durn = 10)
plot(vDurn)
@

For the \emph{contents} of a sequence animation, the \code{start}
value represents a delay that is relative to the end of the previous
animation in the sequence. For example, the following code generates
an atomic animation that starts after a delay of 0.5 seconds and lasts
for 2 seconds. If this animation is used as part of an animation
sequence, the delay on the atomic animation creates a pause within the
sequence (see \autoref{fig:contentDelay}).

<<contentDelay, echo = -3, fig.height = 2, out.height = "2in", fig.cap = "A sequence animation (consisting of four atomic animations) where the fourth atomic animation has a delay.">>=
d <- atomic(start = 0.5, durn = 2)
vContentDelay <- vec(a, b, c, d)
plot(vContentDelay)
@

For the contents of track animations, a delay is just relative to the
start of the track animation. For example, the following code
generates a track animation from two atomic animations where the
second atomic animation has a delay of 0.5 seconds so it starts after
the first atomic animation (see \autoref{fig:trackContentDelay}).

<<trackContentDelay, echo = -2, fig.cap = "A track animation (consisting of two atomic animations) where the second atomic animation has a delay.">>=
tContentDelay <- trac(a, d)
plot(tContentDelay)
@

It is also possible for the container to override the start and
duration values for its contents. This is achieved by specifying a
\emph{vector} of values for either \code{start} or \code{durn}. The
following code shows this feature being used to insert a delay between
animations within a sequence. There are three atomic animations in the
sequence, each of which has a start of zero, but the sequence
animation specifies \code{start} values of 0, 0.5, and 0.5, which
override the atomic animation start values (see
\autoref{fig:vecParentDelay}).

<<vecParentDelay, echo = -2, fig.height = 2, out.height = "2in", fig.cap = "A sequence animation (consisting of three atomic animations) where the parent sequence has inserted a delay between the atomic animations.">>=
vParentDelay <- vec(a, b, c, start = c(0, 0.5, 0.5))
plot(vParentDelay)
@

The following code combines the three atomic animations into a track
animation where the track animation specifies start values for the
atomic animations in order to stagger the start of the animations
within the track (see \autoref{fig:trackParentDelay}).

<<trackParentDelay, echo = -2, fig.cap = "A track animation (consisting of three atomic animations) where the parent track has staggered the start of the atomic animations.">>=
tParentDelay <- trac(a, b, c, start = c(0, 0.5, 1))
plot(tParentDelay)
@

An example of the container explicitly controlling the duration of its
contents will be shown later in \autoref{subsec:anim-examples}.

Another possibility is that an atomic animation may abdicate
responsibility for its duration to its parent container. This is
achieved by specifying \code{NA} for the \code{durn} of an atomic
animation. This only works if the container animation is not also
relying on calculating its duration from its contents.

In the case of a sequence animation, if the container has an explicit
duration then any atomic content of the container can have \code{NA}
duration, in which case the container duration is equally shared out
amongst such atomic content.

In the case of a track animation, if either the container has an
explicit duration or at least one animation in the contents of the
container has an explicit duration (from which the container can
calculate its duration), then any atomic content with \code{NA}
duration is given the container duration.

For example, the following code generates a sequence animation from
five atomic animations, where the second and fourth atomic animations
have \code{NA} duration. The sequence animation has an explicit
duration of 10 seconds, three of the atomic animations have a combined
duration of 6 seconds, so the two atomic animations with \code{NA}
duration get 2 seconds each (4 seconds divided by 2).

<<naVec, echo = -3, fig.height = 2, out.height = "2in", fig.cap = "A sequence animation consisting of five atomic animations, where the second and fourth atomic animations have a duration of \\code{NA}, so their duration is calculated from the parent sequence.">>=
f <- atomic(durn = NA)
navec <- vec(a, f, b, f, c, durn = 10)
plot(navec)
@

In the following code, a track animation is generated from four atomic
animations, with the fourth atomic animation having \code{NA}
duration. The fourth atomic animation gets the same duration as the
longest of the atomic animations with a known duration.

<<naTrack, echo = -2, fig.cap = "A track animation consisting of four atomic animations, where the fourth atomic animation has a duration of \\code{NA}, so its duration is calculated from the longest of the atomic animations with a known duration.">>=
natrac <- trac(a, b, c, f)
plot(natrac)
@

\subsection{Operations on containers}

Several useful manipulations are possible on container animations. For
example, there is a \code{rep()} method to generate regular patterns
of animation actions. The following code shows a sequence animation
being repeated three times (see \autoref{fig:repEx}).

<<repEx, echo = -2, fig.height = 2, out.height = "2in", fig.cap = "A sequence animation (consisting of three atomic animations) repeated three times.">>=
vRep <- rep(v, 3)
plot(vRep)
@

Notice that the result of repeating a container is just a container
with the original \emph{contents} repeated (not a container with the
original container repeated). The result of repeating an atomic
animation is special and it produces a container animation (by default
a sequence, but a boolean \emph{vec} argument allows the result to be
a track animation instead).

It is also possible to subset a container. Single square brackets
produce a smaller version of the original container, consisting of a
subset of the original contents, and double square brackets produce a
single item from the original contents. The following code shows
various subsets being generated from a sequence animation.

<<containerOps, echo = -(1:2)>>=
cat('R> vRep')
cat(lineTrim(capture.output(vRep)))
vRep[2]
class(vRep[2])
vRep[[2]]
class(vRep[[2]])
vRep[3:5]
vRep[c(TRUE, FALSE)]
vRep[rep(2:3, 2)]
@

Assignment to a subset of a container animation is also possible,
using both single and double square brackets. The value being assigned
must be compatible with the container so, for example, only a sequence
animation can be assigned to a subset of a sequence animation, and an
atomic animation may only be assigned using double square brackets.

Finally, there is a \code{splice()} function for inserting new content
into a container animation. Both atomic animations and container
animations may be inserted into a container. For example, the
following code appends an atomic animation onto the end of a sequence
animation of three atomic animations to make a sequence of four atomic
animations (see \autoref{fig:spliceVec}) and then splices in a track
animation after position 2 in the sequence (see
\autoref{fig:spliceTrack}).

<<spliceVec, echo = -3, fig.height = 2, out.height = "2in", fig.cap = "A sequence animation (consisting of three atomic animations) with a fourth atomic animation appended.">>=
e <- atomic(durn = 1)
vAppend <- splice(v, e)
plot(vAppend)
@

<<spliceTrack, echo = -2, fig.cap = "A sequence animation (consisting of four atomic animations) with a track animation spliced in after the second atomic animation.">>=
vSplice <- splice(vAppend, t, after = 2)
plot(vSplice)
@

In addition to the \code{after} argument to \code{splice()}, which
allows animations to be inserted in between existing animations in a
sequence or track, there is also an \code{at} argument to
\code{splice()}, which allows animations to be inserted
\emph{alongside} existing animations in a sequence or track. For
example, the following code splices an atomic animation into a
sequence animation at position 2. The result is a sequence that splits
into two tracks at position 2; one track has the original remainder of
the sequence and the other track has the spliced in atomic animation
(see \autoref{fig:seqAlongside}).

<<seqAlongside, echo = -3, fig.cap = "A sequence animation (consisting of three atomic animations) with a new atomic animation spliced in alongside the second atomic animation in the original sequence.">>=
sequence <- vec(a, b, c)
newSeq <- splice(sequence, e, at = 2)
plot(newSeq)
@

\subsection{Timing schemes}

The ultimate purpose of constructing an animation description is to be
able to coordinate the timing of multiple animation actions. The
\code{timing()} function is provided to turn an animation description
into a timing scheme. The following code shows the simplest case for
an atomic animation. This shows the basic information that is produced
for each atomic animation: the label of the animation, when it starts
and its duration (the animation diagram is also shown in
\autoref{fig:atomTiming} for comparison).

<<atomTiming, echo = -2, fig.height = 2, out.height = "2in", fig.cap = "A simple atomic animation that starts at after 0 seconds and lasts for 1 second.">>=
timing(a)
plot(a)
@

The next example shows the timing information from a sequence
animation (consisting of three atomic animations; see
\autoref{fig:seqTiming}). The first thing to note is that there is a
line of timing information for each atomic animation. Secondly, in
addition to the basic start and duration information, there is
information about the \emph{context} in which the atomic animation
occurs. In particular, the context tells us the sequence animation and
the track animation in which each atomic animation occurs, plus which
iteration within the sequence animation and which track within the
track animation the atomic animation represents. In this case, the
atomic animations are the first, second, and third iterations within a
single sequence animation (and there are no tracks).

<<seqTiming, echo = -2, fig.height = 2, out.height = "2in", fig.cap = "A simple sequence animation consisting of three atomic animations.">>=
timing(v)
plot(v)
@

The next example shows a more complex animation, consisting of a
sequence animation made up from a sequence animation followed by a
track animation (see \autoref{fig:trackTiming}). One complication is
that there are now many atomic animations to give timing information
for. There is also a lot more context information to convey for each
atomic animation. For example, the third atomic animation starts after
0 seconds and lasts for 3 seconds. This atomic animation is part of
the first iteration within a sequence \emph{and} it is on the third
track of a track animation. The fourth atomic animation starts after 3
seconds and lasts for 1 second. This atomic animation is the first
iteration within a sequence, which is itself the second iteration
within a parent sequence.

<<trackTiming, echo = -2, fig.cap = "A sequence animation that consists of a track animation followed by a sequence animation.">>=
timing(container)
plot(container)
@

Although the timing information for this example is relatively
complex, it is still straightforward to extract the basic information
for any atomic animation. The information for the overall animation is
structured as a list, with one component for each atomic
animation. The information for each atomic animation is itself just a
list of seven components. For example, the following code shows how we
can easily extract just the start time and duration for the fourth
atomic animation.

<<timingExtract>>=
tim <- timing(container)
tim[[4]]$start
tim[[4]]$durn
@

It is also important to note that the context information is stored as
a \emph{vector} of information for each atomic animation. For example,
the following code shows the sequence context for the fourth atomic
animation.

<<timingContext>>=
tim[[4]]$vec
tim[[4]]$vecNum
@

It is therefore possible to use this contextual information
programmatically to determine useful information about when within a
larger animation a particular atomic animation occurs.

Another way to access timing information is to ask which atomic
animations are \emph{active} at a particular time point. This sort of
information is more useful for generating an animation as a series of
static frames because it provides information about what to draw
within each frame.

The \code{frameTiming()} function returns timing information for
atomic animations that are active at a specific time point. For
example, the following code tells us that, after 1.5 seconds of the
\code{container} sequence animation, atomic animations \code{b} and
\code{c} are active (within track 2 and track 3 of the first step in
the parent sequence, respectively; see \autoref{fig:trackTiming}) and
after 5 seconds only \code{b} is active (this time as step 2 of the
sequence within step 2 of the parent sequence see
\autoref{fig:trackTiming}).

<<fTiming>>=
frameTiming(container, 1.5)
frameTiming(container, 5)
@

A \code{frameApply()} is also provided to call a user-specified
function on the timing information for an animation at a set of time
points (frames) spanning the entire animation. The default is just to
print the timing information for each frame, but this can be used to
draw the content for each frame (an example is given in
\autoref{subsec:anim-examples}). The following code shows the default
output from \code{frameApply()} for the simple sequence animation
\code{v} with one frame per second.

<<fApplyEx>>=
capture.output(frameApply(v, pause = FALSE))
@

\subsection{Drawing animation diagrams}

A \code{plot()} method is defined for animations and this was used to
produce all of the figures in this report. There is also a
\code{dynPlot()} function, which draws a dynamic (SVG) version of the
diagram in which each rectangle is animated appropriately.

\subsection{Examples}
\label{subsec:anim-examples}

This subsection provides some demonstrations of how these functions
could be used to construct animations.

The first example shows a sequence being constructed from many
repetitions of an atomic animation. The idea here is that there is an
atomic animation that is demonstrated a few times slowly, then again a
bit faster, and a third time very fast. The atomic animation is
identical each time and the container varies the duration (see
\autoref{fig:longSeq}).

<<longSeq, echo = -3, fig.height = 2, out.height = "2in", fig.cap = "A sequence animation (consisting of four atomic animations) with a track animation spliced in after the second atomic animation.">>=
r <- rep(a, 15)
durn(r) <- rep(c(10, 5, 1), each = 5)
plot(r)
@

\subsubsection{A \gridSVG{} example}
\label{subsub:animaker-grid-ex}

The \gridSVG{} package includes the \code{grid.animate()} function,
which enables us to declaratively embed animations within an SVG
image. In order to demonstrate how the \pkg{animaker} can be used in
conjunction with \gridSVG{}, we will perform the following animation:

\begin{enumerate}

\item Begin with a black rectangle called \code{mainrect} at the left
  of the page.

\item Move the rectangle from the left of the page to the right of the
  page in two seconds.

\item Change the fill colour to white and move from the right of the
  page to the centre of the page in 1 second.

\item Change the fill color to red and end the animation after 1
  second.

\end{enumerate}

This can be described in \pkg{animaker} with the following sequence:

<<descAnim, echo = -5, fig.height = 2, out.height = "2in", fig.cap = "Describing an example animation that is a sequence animation composed of three atomic animations.">>=
moveRight <- atomic(durn = 2, label = "moveRight")
changeAndMove <- atomic(durn = 1, label = "changeAndMove")
fillRed <- atomic(durn = 1, label = "fillRed")
completeAnim <- vec(moveRight, changeAndMove, fillRed,
                    label = "completeAnim")
plot(completeAnim)
@

The animation sequence has now been described, but we have yet to
write any actions for this sequence. Each action function should take
a single parameter, which is a timing object (i.e. the result of
calling \code{timing()} on an animation). This object contains all the
information that an animation function needs to know to apply its
action. It therefore requires no hard-coding of any timing
information.

<<actionFunctions>>=
# Action functions that apply each step of the animation
moveRect <- function(info) {
    grid.animate("mainrect",
                 x = c(0.2, 0.8),
                 begin = info$start,
                 duration = info$durn)
}
moveAndFillWhite <- function(info) {
    grid.animate("mainrect",
                 x = c(0.8, 0.5),
                 fill = "white",
                 begin = info$start,
                 duration = info$durn)
}
fillRed <- function(info) {
    grid.animate("mainrect",
                 fill = "red",
                 begin = info$start,
                 duration = info$durn)
}
# Wrapper function that selects which action function to call
animate <- function(info) {
    if (info$label == "moveRight")
        moveRect(info)
    if (info$label == "changeAndMove")
        moveAndFillWhite(info)
    if (info$label == "fillRed")
        fillRed(info)
}
@

We can now apply these actions and then export to SVG to view the
animation sequence.

<<applygridsvganimseq, echo = -c(1, 8), fig.height = 2, out.height = "2in", fig.cap = "The starting point for our example animation sequence.">>=
grid.rect()
# Drawing our starting rectangle
grid.rect(x = 0.2, name = "mainrect",
          width = unit(1, "inches"), height = unit(1, "inches"),
          gp = gpar(fill = "black"))
# Applying animation functions using timing information
tim <- timing(completeAnim)
invisible(lapply(tim, animate))
# Exporting
cat('R> grid.export("animaker-gridsvg-example.svg")')
@

Screenshots of the resulting animation can be seen in
\autoref{fig:gridsvg-animaker-example}.

\begin{figure}[H]
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=4in]{images/gridsvg-animaker-1.png}
    \caption{The start of the animation where the rectangle has just started moving to the right.}
  \end{subfigure}
\end{figure}
\begin{figure}[H]
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=4in]{images/gridsvg-animaker-2.png}
    \caption{The rectangle has almost reached the right-hand side of the page.}
  \end{subfigure}
\end{figure}
\begin{figure}[H]
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=4in]{images/gridsvg-animaker-3.png}
    \caption{The rectangle has reached the right-hand side of the page, where it was filled with white colour. It is now is moving left.}
  \end{subfigure}
\end{figure}
\begin{figure}[H]
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=4in]{images/gridsvg-animaker-4.png}
    \caption{The rectangle has moved to the centre and has now been filled red.}
  \end{subfigure}
  \caption{Screenshots of a simple animation described by \pkg{animaker} and applied by \gridSVG{}.}
  \label{fig:gridsvg-animaker-example}
\end{figure}

The overall timing of this animation example is not rocket science,
but the \pkg{animaker} package makes the task simpler, encourages
separation between the timing of the animation steps and the actions
that occur in each step, and encourages the animation ``director'' to
break an animation into smaller, simpler steps.

\subsubsection{An \pkg{animation} example}

We will revisit the example shown in \autoref{subsub:animaker-grid-ex}
by creating a frame-based implementation using the \pkg{animation}
package. Instead of relying on a timing scheme created by
\code{timing()}, we use the information returned from the
\code{frameTiming()} function.

The existing animation description enables us to generate timing
information for individual frames. For example, the following code
produces timing information for frames after 0 seconds, 2 seconds,
and 3 seconds, which shows how different animation actions appear in
different frames.

<<showFrameTiming>>=
frameTiming(completeAnim)
frameTiming(completeAnim, 2)
frameTiming(completeAnim, 3)
@

We now need functions that can make use of the timing information to
draw a frame. These functions contain calls to the \code{grid.rect()}
function to draw the animated rectangle for each frame.

<<animPackExample>>=
# global variables that each frame might like
# to know about
fps <- 10
frameNumber <- 0
# Action functions
drawRect <- function(info) {
    rectx <- seq(0.2, 0.8, length.out = fps * info$durn)
    rectx <- rectx[frameNumber - (fps * info$start)]
    grid.rect(x = rectx,
              width = unit(1, "inches"),
              height = unit(1, "inches"),
              gp = gpar(fill = "black"))
}
drawRectThenFillWhite <- function(info) {
    rectx <- seq(0.8, 0.5, length.out = fps * info$durn)
    rectx <- rectx[frameNumber - (fps * info$start)]
    grid.rect(x = rectx,
              width = unit(1, "inches"),
              height = unit(1, "inches"),
              gp = gpar(fill = "white"))
}
fillRectRed <- function(info) {
    grid.rect(x = 0.5,
              width = unit(1, "inches"),
              height = unit(1, "inches"),
              gp = gpar(fill = "red"))
}
@

These functions (e.g. \code{drawRect()} are only ever drawing a single
rectangle each time they are called. They are just a bit more
complicated because they need to select which rectangle to draw, which
are based on starting times and durations (provided by
\pkg{animaker}), and the current frame number and number of frames per
second.

With these functions defined, an overall function can be created to
draw just the components that are active in a frame. This function
makes use of the fact that we chose labels for the atomic actions to
match the names of the functions that draw the different components of
a frame.

<<drawFrameDef>>=
# Delegates frame drawing at each time step
drawFrame <- function(info) {
    frameNumber <<- frameNumber + 1
    grid.newpage()
    lapply(info, function(x) {
        if (x$label == "moveRight")
            drawRect(x)
        if (x$label == "changeAndMove")
            drawRectThenFillWhite(x)
        if (x$label == "fillRed")
            fillRectRed(x)
    })
}
@

We can now play the animation by calling \code{frameApply()}. This
calls our \code{drawFrame()} function for each of a series of
animation frames. The \code{fps} argument specifies that there should
be ten frames drawn per second.

<<frameApplyDemo, echo = FALSE>>=
cat('R> frameApply(completeAnim, drawFrame, fps = 10)')
@

Functions from the \pkg{animation} package can be used to generate an
animated movie from this sequence of frames. For producing a movie we
use more frames per second to get a smoother result and we do not
bother to pause between generating frames.

<<saveToGIF, results = "hide", message = FALSE>>=
# Reset the frame counter
frameNumber <- 0
# Now save via the animation package
library(animation)
saveGIF(frameApply(completeAnim, drawFrame,
                   fps = fps, pause = FALSE),
        interval = 1 / fps, ani.width = 400, ani.height = 200)
@

The result of this code is that we get an animated GIF image that
shows our animation sequence. This is not shown because the images
would appear the same as in
\autoref{fig:gridsvg-animaker-example}. The only difference being that
we had to procedurally draw each frame, so the rectangle's movement
across the page is not fluid.

The timing of this animation makes the contribution of the
\pkg{animaker} package more significant in this case. This is because
at no point did any of the frames need to hard-code their start or
duration times. It is also worth noting that the separation between
the overall timing of the animation and the individual animation
actions is again useful, particularly when experimenting with
different timings. All that was required was to change the animation
descriptions that were shown earlier, everything else flowed from
that.

\subsection{Conclusion}

This section describes an \R{} package that provides a convenient and
flexible way to build descriptions of animation sequences. An
animation description can be used to generate a timing scheme that
contains information about the start and duration of every action in
the animation (or for every frame in the animation).

The main functions in the package are:

\begin{itemize}

\item \code{atomic()} to describe a single step in an animation.

\item \code{vec()} to combine animation steps in series.

\item \code{trac()} to combine animation steps in parallel.

\item \code{timing()} to generate a timing scheme for an animation.

\end{itemize}

Further functions are provided to manipulate animation descriptions
and there are functions for drawing diagrams to help visualise
animations descriptions.

\subsubsection{Acknowledgements}

The concepts of sequence tracks and sequence animations derive their
intellectual ancestry from various systems that can be used to
coordinate multimedia resources. These include Microsoft \pkg{Movie
  Maker}, Microsoft \pkg{PowerPoint}, Adobe \pkg{Flash}, and several
\proglang{JavaScript} libraries: \pkg{Timeline.js}
\autocite{timeline}, \pkg{burst-core} \autocite{burstcore}, and
Mozilla's \pkg{Popcorn.js} \autocite{popcornjs}.

\section{Applying Animation Sequences in \proglang{JavaScript}}

The \pkg{animaker} package can be used to describe an animation
sequence, which allows us to focus on when animation actions should
occur. It does not express any description of an animation action,
only representing them by labels. The key result from describing an
animation sequence is the ability to generate timing schemes from
it. These timing schemes tell us when an animation is to occur, for
how long, and what its context is. For example, the context can tell
us whether an animation action is the first, second, or third action
within a sequence of actions.

The timing information that is generated by \pkg{animaker} can be
exported for use within a web browser and the \pkg{TimingManager}
library provides us with an easy way of using this timing information.

This does not allow us to modify exported animations but it enables us
to use the animations created by the \pkg{animaker}
package. \pkg{animaker} tells us when an animation occurs, and its
duration, but it does not assign actions to animations. The
\pkg{TimingManager} library not only assigns actions to animation
descriptions, it also allows us to play back animations in a simple
manner.

We demonstrate how \pkg{TimingManager} can be used for both
declarative animation and iterative animation by frames. The
declarative animation is demonstrated via \pkg{D3} and its use of SVG
and CSS transitions. The framed animation is performed by the HTML
\code{<canvas>} element, which uses a painter-model approach, rather
than SVG's object-based approach to image construction.

\subsection{Exporting an Animation Sequence}

An example showing how \pkg{animaker} and \pkg{TimingManager} can be
used together will be demonstrated by creating a simple plot where we
have 3 squares that move around and change colour. The aim is to
perform the following animation sequence:

\begin{enumerate}
\item Move a red square from left to right. This starts immediately
  and lasts for 1 second. The square will turn black once it has
  completed moving.
\item Move a green square from right to left. This starts 1 second
  after the previous animation and lasts for 1 second. The square will
  turn black once it has completed moving.
\item Move a blue square from the left to the middle of the plot. This
  starts 1 second after the previous animation and lasts for 1
  second. The square will turn black once it has completed moving.
\item All squares will then move into the centre of the plot, also
  transitioning to white. This starts 1 second after the previous
  animation and lasts for 3 seconds.
\end{enumerate}

Now that we have described this animation sequence, we first need to
describe the timings of the animation sequence using \pkg{animaker}
within \R{}.

<<descTimings>>=
library(animaker)
redSq <- atomic(label = "red", durn = 1)
greenSq <- atomic(label = "green", start = 1, durn = 1)
blueSq <- atomic(label = "blue", start = 1, durn = 1)
final <- atomic(label = "final", start = 1, durn = 3)
# Combine animations into a sequence
completeAnim <- vec(redSq, greenSq, blueSq, final,
                    label = "complete")
@

A description of the animation has now been created. This enables us
to create a timing scheme that tells us when each action is to be
called, along with the context in which it is being applied.

<<showExTimings>>=
timing(completeAnim)
@

We can see what this timing information looks like by calling
\code{plot()} on our animation description. This is shown in
\autoref{fig:showExPlot}.

<<showExPlot, fig.height = 2, out.height = "2in", fig.cap = "A sequence animation composed of four atomic animations.">>=
plot(completeAnim)
@

Now that the description of the animation sequence has been created,
we need to be able to export it into a form that a web browser can
use. In order to perform this task, \pkg{animaker} uses the
\pkg{RJSONIO} package \autocite{Lan13b}. This package translates \R{}
data structures into JSON equivalents. This means we can access the
data in \proglang{JavaScript} that has been exported from \R{} in a
natural manner. \pkg{animaker} can export animation timings to a
\proglang{JavaScript} variable that is assigned timing information. We
do this by calling the \code{export()} function, as shown below.

<<exportTimings>>=
export(completeAnim,
       jsVar = "simpleAnim",
       file = "simple-anim-timing.js")
@

What is happening here is that the timing information is going to be
represented as a \proglang{JavaScript} object that is assigned to a
variable called \code{simpleAnim}. The resulting code is saved to a
file called \code{simple-anim-timing.js}. The first 20 lines of the
file \code{simple-anim-timing.js} are the following:

<<showExportedJSON, echo = FALSE>>=
exportedJSON <- paste0("var simpleAnim = ",
                       toJSON(timing(completeAnim), pretty = TRUE), ";")
exportedJSON <- strsplit(gsub("\t", "    ", exportedJSON), "\n")[[1]]
cat(paste(exportedJSON[1:19], collapse="\n"), "\n...\n")
@

What we can see is that there is a close mapping between the timing
scheme we printed out earlier and the JSON that was exported from
it. The headers in our timing scheme have now become keys in
\proglang{JavaScript} objects, each object representing a row in our
timing scheme.

We can import this information into the browser using the HTML
\code{<script>} tag. This allows us to make use of \pkg{TimingManager}
because we exposed a \proglang{JavaScript} variable,
\code{simpleAnim}, which contains all of the necessary timing
information.

\subsection{Using Timing Information in the Browser}
\label{sec:applyseq}

In order to use the exported timing information, we will first begin
by instantiating a \pkg{TimingManager} object in
\proglang{JavaScript}. There are two parameters of interest when
constructing this object; the first of which is simply the timing
information that we have previously stored in a \proglang{JavaScript}
variable. The second parameter is simply noting that we are using
seconds as the base unit of time.

<<instTM, echo = FALSE>>=
jsLine('var tm = new TimingManager(simpleAnim, "s");')
@

Next we create \proglang{JavaScript} functions that we will assign as
actions to our atomic animations. For clarity, the code used to
generate the initial scene has been omitted. Note that each of the
following functions takes a single parameter which contains the
information about the animation as it is being called. In this case,
the timing information is used to set the duration of each animation.

<<actionFnDefs, echo = FALSE>>=
jsLine('var redAction = function(info) {')
jsLine('d3.select("#redsq")', prefix = "JS+     ")
jsLine('.transition()', prefix = "JS+         ")
jsLine('.duration(info.durn * 1000)', prefix = "JS+         ")
jsLine('.attr("x", 400)', prefix = "JS+         ")
jsLine('.transition()', prefix = "JS+         ")
jsLine('.attr("fill", "black");', prefix = "JS+         ")
jsLine('};', prefix = "JS+ ")
jsLine('var greenAction = function(info) {')
jsLine('d3.select("#greensq")', prefix = "JS+     ")
jsLine('.transition()', prefix = "JS+         ")
jsLine('.duration(info.durn * 1000)', prefix = "JS+         ")
jsLine('.attr("x", 100)', prefix = "JS+         ")
jsLine('.transition()', prefix = "JS+         ")
jsLine('.attr("fill", "black");', prefix = "JS+         ")
jsLine('};', prefix = "JS+ ")
jsLine('var blueAction = function(info) {')
jsLine('d3.select("#bluesq")', prefix = "JS+     ")
jsLine('.transition()', prefix = "JS+         ")
jsLine('.duration(info.durn * 1000)', prefix = "JS+         ")
jsLine('.attr("x", 250)', prefix = "JS+         ")
jsLine('.transition()', prefix = "JS+         ")
jsLine('.attr("fill", "black");', prefix = "JS+         ")
jsLine('};', prefix = "JS+ ")
jsLine('var finalAction = function(info) {')
jsLine('d3.select("#redsq, #greensq, #bluesq")', prefix = "JS+     ")
jsLine('.transition()', prefix = "JS+         ")
jsLine('.duration(info.durn * 1000)', prefix = "JS+         ")
jsLine('.attr({', prefix = "JS+         ")
jsLine('x: 250,', prefix = "JS+             ")
jsLine('y: 250,', prefix = "JS+             ")
jsLine('fill: "white"', prefix = "JS+             ")
jsLine('});', prefix = "JS+         ")
jsLine('};', prefix = "JS+ ")
@

The only timing calculation we needed to make is to convert seconds to
milliseconds. This is because \pkg{D3}, like almost all time related
\proglang{JavaScript} code, uses milliseconds as its primary unit of
time. Although the \pkg{D3} code shown above is what we're going to be
using to perform animation, it is not strictly necessary to understand
it, only the resulting actions it performs.

In order to bind actions to animations, we need to \emph{register} the
actions within \pkg{TimingManager}. To do this, we simply build a
\proglang{JavaScript} object that has animation labels as its keys,
and the associated actions as its values. This is shown below:

<<registerActions, echo = FALSE>>=
jsLine('tm.register({')
jsLine('red: redAction,', prefix = "JS+     ")
jsLine('green: greenAction,', prefix = "JS+     ")
jsLine('blue: blueAction,', prefix = "JS+     ")
jsLine('final: finalAction', prefix = "JS+     ")
jsLine('});', prefix = "JS+ ")
@

Now that the actions have been \emph{registered} to atomic animations,
we can \emph{play} them.

<<playAnim, echo = FALSE>>=
jsLine('tm.play();')
@

When \code{play()} is called, \pkg{TimingManager} begins to call the
animation actions at the correct times. The final implementation of
the animation sequence is shown in \autoref{fig:tm-demo}. Because the
animations and indeed the \proglang{JavaScript} code runs in a web
browser, screenshots have been taken. Consequently, it must be assumed
that the images capture the described functionality. In a web browser,
the animation sequence begins by clicking the ``Play'' button.

\begin{figure}[H]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=3in]{images/tm-demo-1.png}
    \caption{The web page prior to clicking the ``Play'' button.}
  \end{subfigure}
\end{figure}
\begin{figure}[H]
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=3in]{images/tm-demo-2.png}
    \caption{The red square moving to the right.}
  \end{subfigure}
\end{figure}
\begin{figure}[H]
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=3in]{images/tm-demo-3.png}
    \caption{The red square has finished moving and has now turned black.}
  \end{subfigure}
\end{figure}
\begin{figure}[H]
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=3in]{images/tm-demo-4.png}
    \caption{The green square has moved to the right and turned black. The blue square is currently moving to the right.}
  \end{subfigure}
\end{figure}
\begin{figure}[H]
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=3in]{images/tm-demo-5.png}
    \caption{All three squares moving towards the centre of the screen and fading to white.}
  \end{subfigure}
  \caption{An animation sequenced with \pkg{animaker} and applied in \proglang{JavaScript} with \pkg{TimingManager} and \pkg{D3}.}
  \label{fig:tm-demo}
\end{figure}

\subsection{Complex Examples}

More complex examples will be shown that use \R{} to describe
animation sequences with \pkg{animaker}, but do not require \R{} to
produce any graphics. The first of these examples is an equivalent of
\pkg{animaker}'s \code{dynPlot()} function. \code{dynPlot()} produces
an animated plot showing visually when each atomic animation is due to
be called. The second is a quick demonstration of frame-based
animation in the browser.

\subsubsection{Animated Timing Plot}

To begin, we will first create an animation and export it from
\R{}. We first need to load the \pkg{animaker} package.

<<loadAnimaker>>=
library(animaker)
@

By taking some of the code from \autoref{sec:descseq}, we can
reconstruct an animation.

<<buildAnims>>=
a <- atomic(label = "Alpha", durn = 1)
b <- atomic(label = "Bravo", durn = 2)
c <- atomic(label = "Charlie", durn = 3)
f <- atomic(label = "Delta", durn = NA)
navec <- vec(a, f, b, f, c, durn = 10)
# We'll have this repeated 3 times
navec <- rep(navec, 3)
@

We can export the timing information from this animation sequence into
a form that can be used in the browser.

<<exportAnims>>=
# Store timing information
timingData <- timing(navec)
# Turn it into a JS variable and save
export(timingData,
       jsVar = "timingData",
       file = "timing-data.js")
@

The file \code{timing-data.js} can now be used within an HTML document
so that we can use this timing information within a web browser. Once
we have the data exported from \R{}, we can begin to use the timing
information in the browser.

The implementation details have been omitted for brevity but we are
able to make use of \pkg{D3} to create a plot. The fact that this is
designed to be viewed in a web page means we can only show screenshots
of the timing plot (see \autoref{fig:d3-timing-plot}). Note that the
\emph{actions} associated with each atomic animation are going to be
appending text below the timing plot. By clicking the ``Play'' button
in a web browser we can visualise how the playback is going to occur,
along with triggering associated actions.

\begin{figure}[H]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=3in]{images/d3-timing-plot-1.png}
    \caption{The timing plot prior to clicking the ``Play'' button.}
  \end{subfigure}
\end{figure}
\begin{figure}[H]
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=3in]{images/d3-timing-plot-2.png}
    \caption{Two actions have been performed that append text showing their name, when they started, and how long they run for.}
  \end{subfigure}
\end{figure}
\begin{figure}[H]
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=3in]{images/d3-timing-plot-3.png}
    \caption{The timing plot as it appears after running for approximately 10 seconds.}
  \end{subfigure}
  \caption{A timing plot generated from exported timing information.}
  \label{fig:d3-timing-plot}
\end{figure}

We can see that actions for each animation are simply to print out
their labels, along with the starting times and their durations. This
is a simple diagram demonstrating how timing information can be used,
but instead of simply appending some text, we could be performing any
task that is possible within \proglang{JavaScript}.

\subsubsection{Framed Animation}

In the case of framed animation, the intention is to provide the
illusion of animation by producing several frames close together. This
effect is employed in films where 24 individual frames are shown per
second, but because they are shown close together, the illusion of a
moving picture is produced. In the browser, a natural way of
performing this task is by using the \code{<canvas>} element. This is
mostly useful if we do not have the ability to employ declarative
animation, as is the case with \R{} graphics devices.

A frame-based animation has been created, using the same animation
sequence description from the previous section. The key difference is
that we need to overwrite the actions that are registered with
animations, using new action functions. In order to do this, we simply
register the actions again, but with an additional parameter, which
determines whether we can overwrite definitions. The following code
demonstrates this:

<<registerFramed, echo = FALSE>>=
jsLine('tm.register({')
jsLine('Alpha: alphaFrameAction', prefix = "JS+     ")
jsLine('Bravo: bravoFrameAction', prefix = "JS+     ")
jsLine('Charlie: charlieFrameAction', prefix = "JS+     ")
jsLine('Delta: deltaFrameAction', prefix = "JS+     ")
jsLine('}, true);', prefix = "JS+ ")
@

For the sake of brevity, we will not show the definitions of each of
the action functions. However, their definitions are such that they
aim to simply draw a filled rectangle when they are
called. Additionally, they append text to a field below the plot, so
we can see when the ``frames'' are being drawn.

Now that we have our timing information and our actions registered we
can play our frame-based animation. To do this, we call the
\code{frameApply()} method. It requires a single parameter, which
represents the number of frames to draw per second.

<<runFrameApply, echo = FALSE>>=
jsLine('tm.frameApply(10);')
@

The result of this function call is that animation actions are
repeatedly called for the duration of their actions, rather than just
once at the starting point of the animation. The resulting animation
that has been constructed is shown in \autoref{fig:frame-anim}.

\begin{figure}[H]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=3in]{images/frame-anim-1.png}
    \caption{The animation prior to clicking the ``Play'' button.}
  \end{subfigure}
\end{figure}
\begin{figure}[H]
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=3in]{images/frame-anim-2.png}
    \caption{The ``Delta'' action is being executed on frame 16.}
  \end{subfigure}
\end{figure}
\begin{figure}[H]
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=3in]{images/frame-anim-3.png}
    \caption{The ``Bravo'' action being executed on frame 48.}
  \end{subfigure}
  \caption{An example of a \code{<canvas>} based animation.}
  \label{fig:frame-anim}
\end{figure}

Instead of each action describing how to perform an animation, the
action simply draws to a canvas. We can also see that a frame counter
is being shown to make it clear that we really are drawing multiple
times, even if it doesn't appear to be the case.

An example beyond this simple demonstration for frame-based animations
has not been created. The main reason for this is because in a web
browser we usually have the capacity to apply declarative
animations. Declarative animations should be preferred to frame-based
animations primarily because they are much simpler to write. Another
reason is because web browsers are able to hardware accelerate
declarative animations, whereas frame-based animations do not gain
this benefit. As a result, declarative animations are almost always
going to look more pleasant than an equivalent frame-based approach.

\subsection{Conclusion}

This has been a quick demonstration to show how we can use both framed
animation and declarative animation within a web browser. The use of
\R{}s \pkg{animaker} package and \pkg{TimingManager} provide a
convenient interface to describe and apply animations respectively. It
allows us to separate the task of describing \emph{when} things are
happening from the task of describing \emph{what} the animations are
aiming to show.
