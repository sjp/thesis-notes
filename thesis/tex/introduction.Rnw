<<echo = FALSE, results = "hide", message = FALSE>>=
source("../knitr-settings.R")
@

\chapter{Introduction}

\section{What are these Graphics?}

There are numerous software packages that are capable of creating
graphs of some form. Many of these packages are also capable of
producing statistical graphics --- graphs which communicate statistical
information. The \R{} statistical software system \autocite{R13} is a
popular example of software which generates statistical graphics. The
great strength of \R{} is its wealth of statistical functions and
graphics, but only for static graphics. The proliferation of dynamic
and interactive web-based graphics using \proglang{JavaScript}
libraries such as \pkg{D3} \autocite{Bos13} shows that there is
significant interest in creating these graphics in web browsers.

In order to explain the types of graphics we wish to create, we will
first examine what can currently be produced by \R{}, and how they are
used within a web browser.

<<diagramStatic, echo = FALSE, message = FALSE, fig.height = 2, out.height = "2in">>=
simplePlot <- function() {
  pushViewport(dataViewport(xData = cars$speed, yData = cars$dist,
                            width = unit(1, "npc") - unit(1, "cm"),
                            height = unit(1, "npc") - unit(1, "cm")))
  grid.points(x = cars$speed, y = cars$dist, size = unit(0.2, "char"))
  grid.xaxis(label = FALSE)
  grid.yaxis(label = FALSE)
  popViewport()
}

grid.newpage()
l <- grid.layout(ncol = 5, widths = unit(rep(0.2, 5), "npc"))
pushViewport(viewport(layout = l))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("R", gp = gpar(fontsize = 32))
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
grid.text("png()\nsvg()", x = 0.5, y = 0.6, just = "bottom",
          gp = gpar(fontfamily = "mono"))
grid.lines(y = rep(0.5, 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 3))

pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()

popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 4))
grid.lines(y = rep(0.5, 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 5))
pushViewport(viewport(width = 0.8, height = 0.8))
grid.rect()
pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()
popViewport()
popViewport()
popViewport()
@

This figure demonstrates that \R{} can generate a static image using
its built-in graphics devices. In this example the \code{png} and
\code{svg} devices can produce PNG (Portable Network Graphics) and SVG
(Scalable Vector Graphics) images respectively. These images are
static, and can be included in an HTML (Hypertext Markup Language)
document using the \code{<img>} tag.

When we include images onto a web page in this manner, the effect is
largely the same as if we were treating the HTML document as a piece
of paper. One useful feature of web browsers is the ability view
content that is not fixed, and thus unlike a piece of paper. A key
example of this is when we want to include animated graphics within a
web page. There are packages for \R{} that enable animation within a
web browser, we will first consider the prominent \pkg{animation}
package.

The \pkg{animation} package uses software outside of \R{} to construct
its animations, e.g. \pkg{ImageMagick} \autocite{} and \pkg{ffmpeg}
\autocite{}. These are additional pieces of software required to
produce animations in various formats. The general idea of
\pkg{animation} is to repeatedly draw entire plots, each of which are
saved. The saved images are then stitched together into one of the
many formats that \pkg{animation} supports. This means that
\pkg{animation} can create an animated GIF (Graphics Interchange
Format) or a video out of the images that have been saved. The
resulting video or animated GIF can then be inserted into a web page
using the appropriate HTML tag (\code{<video>} and \code{<img>}
respectively).

<<diagramAnimation, echo = FALSE, message = FALSE, fig.height = 2, out.height = "2in">>=
library(gridSVG)

simplePlot <- function() {
  pushViewport(dataViewport(xData = cars$speed, yData = cars$dist,
                            width = unit(1, "npc") - unit(1, "cm"),
                            height = unit(1, "npc") - unit(1, "cm")))
  grid.points(x = cars$speed, y = cars$dist, size = unit(0.2, "char"))
  grid.xaxis(label = FALSE)
  grid.yaxis(label = FALSE)
  popViewport()
}

grid.newpage()
l <- grid.layout(ncol = 5, widths = unit(rep(0.2, 5), "npc"))
pushViewport(viewport(layout = l))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("R", gp = gpar(fontsize = 32))
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
grid.text("png()\nsvg()", x = 0.3, y = 0.7, just = "bottom",
          gp = gpar(fontfamily = "mono"))
grid.polyline(x = rep(c(0, 1), 3),
              y = c(0.5, 5/6, rep(0.5, 2), 0.5, 1/6),
              id = rep(1:3, each = 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 3))

pushViewport(viewport(layout = grid.layout(nrow = 3)))
for (i in 1:3) {
  pushViewport(viewport(width = 0.7, height = 0.5,
                        layout.pos.row = i, layout.pos.col = 1))
  grid.rect()
  simplePlot()
  popViewport()
}
popViewport()

popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 4))
grid.text("animation", y = 0.6, just = "bottom")
grid.lines(y = rep(0.5, 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 5))
pushViewport(viewport(width = 0.8, height = 0.8))
grid.rect()
pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()
popViewport()
popViewport()
popViewport()
@

The method for using \pkg{animation} is demonstrated in
**FIGURE**. The main idea to get across is that several images are
generated by \R{}, which are then stitched together into an
animation-capable format using \pkg{animation}. The result is then
included into a web page.

An alternative to using \pkg{animation} is to write some
\proglang{JavaScript} to be included within an HTML document. The
\proglang{JavaScript} can recreate an animation by referring to
generated static images, and then repeatedly update the HTML to
reference the next image in the sequence. The described behaviour is
in fact already provided by \pkg{animation} through its
\code{saveHTML} function. However, it is a ``black box'' solution
which may not be suitable for all needs. Furthermore, it does not
enable further interactivity that may be possible by writing our own
\proglang{JavaScript} and HTML code. This approach is illustrated
below:

<<diagramHTMLJS, echo = FALSE, message = FALSE, fig.height = 2, out.height = "2in">>=
library(gridSVG)

simplePlot <- function() {
  pushViewport(dataViewport(xData = cars$speed, yData = cars$dist,
                            width = unit(1, "npc") - unit(1, "cm"),
                            height = unit(1, "npc") - unit(1, "cm")))
  grid.points(x = cars$speed, y = cars$dist, size = unit(0.2, "char"))
  grid.xaxis(label = FALSE)
  grid.yaxis(label = FALSE)
  popViewport()
}

grid.newpage()
l <- grid.layout(ncol = 5, widths = unit(rep(0.2, 5), "npc"))
pushViewport(viewport(layout = l))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("R", gp = gpar(fontsize = 32))
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
grid.text("png()\nsvg()", x = 0.3, y = 0.7, just = "bottom",
          gp = gpar(fontfamily = "mono"))
grid.polyline(x = rep(c(0, 1), 3),
              y = c(0.5, 5/6, rep(0.5, 2), 0.5, 1/6),
              id = rep(1:3, each = 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 3))

pushViewport(viewport(layout = grid.layout(nrow = 3)))
for (i in 1:3) {
  pushViewport(viewport(width = 0.7, height = 0.5,
                        layout.pos.row = i, layout.pos.col = 1))
  grid.rect()
  simplePlot()
  popViewport()
}
popViewport()

popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 4))
grid.text("HTML/JavaScript", y = 0.6, just = "bottom")
grid.polyline(x = rep(c(0, 1), 3),
              y = c(5/6, 0.6, rep(0.5, 2), 1/6, 0.4),
              id = rep(1:3, each = 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 5))
pushViewport(viewport(width = 0.8, height = 0.8))
grid.rect()
pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()
popViewport()
popViewport()
popViewport()
@

The \proglang{JavaScript} shown here can be any \proglang{JavaScript}
code that can interact with static images. In practice the
\proglang{JavaScript} code will likely be limited to toggling which
image(s) to display at a given point in time.

A limitation in the types of images that are typically used in web
pages is that they are \emph{raster} images. This means that the image
itself is a description of the colour values encoded in a matrix of
pixels. There is no other information available so we cannot identify
or manipulate any part of a plot.

Another image format that can be used in a web browser is SVG
(Scalable Vector Graphics). SVG is an XML-based (Extensible Markup
Language) vector image format which supports animation and
interactivity (via \proglang{JavaScript}). The fact that SVG is a
vector image format means that we can scale the image to any size and
it will not lose any fidelity. The most encouraging feature is the
XML-based nature of SVG, meaning that SVG inherits behaviour from XML.

The most interesting features of XML for creating SVG are that it is a
structured text format and there is a standard interface for
manipulating an SVG image once it has been loaded, this interface is
called the DOM (Document Object Model). This means that SVG enables
(for example) the colour of a piece of text to change after the image
has been loaded in a browser.

There are two packages for \R{} which use SVG to add interactivity and
animation to plots: \pkg{SVGAnnotation} \autocite{} and \gridSVG{}
\autocite{Mur13}. The key difference between the two packages is how
they produce animated and interactive SVG images. \pkg{SVGAnnotation}
post-processes the SVG produced by \R{}'s \code{svg} device. It also
provides functions for annotating the the post-processed SVG with
animation, tooltips, and linking of two plots. It is possible to add
custom \proglang{JavaScript} to these plots but it is difficult to
write the required code because the structure of the SVG is not clear
and understandable. \gridSVG{} takes the approach of writing its own
SVG output by translating \grid{} primitives into their SVG
equivalents. Animation and interactivity is performed by creating or
annotating \grid{} graphics objects through high-level functions.

The advantage of the \gridSVG{} approach is that because it creates
its own SVG and annotates it with \grid{} object names, it is easier
to manipulate \gridSVG{} output than the output produced by
\pkg{SVGAnnotation}. However, \gridSVG{} is limited to only creating
SVG from \grid{} output, while \pkg{SVGAnnotation} is able to do this
for both the \grid{} and base graphics systems provided by \R{}.

The approach that both of these packages that to produce their plots
can be illustrated by the figure below:

<<diagramSVGAnnGridSVG, echo = FALSE, message = FALSE, fig.height = 2, out.height = "2in">>=
library(gridSVG)

simplePlot <- function() {
  pushViewport(dataViewport(xData = cars$speed, yData = cars$dist,
                            width = unit(1, "npc") - unit(1, "cm"),
                            height = unit(1, "npc") - unit(1, "cm")))
  grid.points(x = cars$speed, y = cars$dist, size = unit(0.2, "char"))
  grid.xaxis(label = FALSE)
  grid.yaxis(label = FALSE)
  popViewport()
}

grid.newpage()
l <- grid.layout(ncol = 5, widths = unit(rep(0.2, 5), "npc"))
pushViewport(viewport(layout = l))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("R", gp = gpar(fontsize = 32))
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
grid.text("SVGAnnotation\ngridSVG", x = 0.3, y = 0.7, just = "bottom")
grid.lines(y = rep(0.5, 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 3))
pushViewport(viewport(width = 0.7, height = 0.7))
grid.rect()
simplePlot()
popViewport()
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 4))
grid.text("JavaScript", y = 0.6, just = "bottom")
grid.lines(y = rep(0.5, 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 5))
pushViewport(viewport(width = 0.8, height = 0.8))
grid.rect()
pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()
popViewport()
popViewport()
popViewport()
@

All of the methods for getting \R{} graphics in the browser have one
features in common --- they are all pre-generated. This means that
whenever a plot is created in \R{}, the statistical information
encoded in that image (or indeed \proglang{JavaScript} code for
\pkg{SVGAnnotation} and \pkg{gridSVG} in particular) becomes fixed. We
cannot add more statistical information to the plot without
communicating with \R{}, which is not possible with the aforementioned
solutions. To produce a plot with different information would require
\R{} to create an entirely new plot, regardless of whether the plot is
static, dynamic or interactive. What this means is that a web page
with embedded statistical graphics cannot update the images without
some way of communicating to \R{}.

There are several existing pieces of software that enable a web
browser to communicate to \R{}. The way this occurs is that a software
package can expose \R{}'s functionality by creating a web server that
can interface with a web browser using HTTP (Hypertext Transfer
Protocol). A web browser can then request resources, such as
statistical documents and graphics. What this means in practice is
that instead of a loading a standalone HTML file on a local hard disk
(or even a remote location), \R{} generates the web page that is
loaded within the browser. Because the web page is generated as it is
requested, it does not need to be fixed.

There are many \R{} packages that are able to perform the described
functionality. Examples of these are \pkg{shiny} \autocite{},
\pkg{Rook} \autocite{} and \pkg{FastRWeb} \autocite{} (which requires
\pkg{RServe} \autocite{}). The details of existing server software
will be discussed in more detail later in this chapter. The general
idea with all of these packages is that a web browser requests a
resource --- usually a web page or an image --- which is generated by
\R{}, then delivered to a web browser.

To explain why these packages are more useful than pre-generated web
pages and images, consider this example. A web page features a scatter
plot with a LOESS Curve where an HTML slider control determines the
size of the smoothing window. Each time the value of the slider
control changes we want to update the plot by replacing the existing
LOESS curve with a new one. This is simple when there is a web server
that communicates to \R{}, because we can just request an entirely new
plot which replaces the existing plot. This simple example is one
where a pre-generated HTML page is infeasible. Attempting a
pre-generated solution would require creating every possible plot,
which in this case is determined by the possible sizes of the LOESS
smoothing window. Because the value of the LOESS spanning window is a
continuous variable, this is not possible as it would require an
incredibly large amount of plots. Even if were to limit the possible
number of plots to 100, that is still a large amount of work to
pre-generate, especially if many of the plots will not be seen.

The pre-generated solutions can be illustrated using the following diagram:

\dots

\textbf{INSERT PLOT}

\dots Explain the plot briefly

\dots

The plots that are dynamically generated can be any one of the types
of plots that were discussed earlier. Typically the dynamically
generated images are simply a static plot, often the result of drawing
the \code{png} device. In the example that was discussed earlier, the
simple method for updating the plot that appeared on the web page was
removing the old image and inserting the newly generated image. If the
goal is to update the LOESS curve then generating an entirely new
image is not only wasteful --- because most of the plot has not
changed --- but it does not give us any way of showing \emph{how} the
curve changed.

What we aim to achieve is to be able to \emph{modify} an \R{} plot
with dynamically generated graphical content within a web
browser. What this requires is not only to be able to communicate with
\R{} to generate new content, but also to be able to identify and
modify \emph{parts} of a plot in a web page. We have already mentioned
that some \R{} packages allow us to communicate with \R{} but there
are few options available for being able to modify parts of a
plot. The only image format that is capable of the desired behaviour
is SVG. \R{}'s \code{svg} device produces SVG that is viewable in a
web browser, but unreadable to anyone who wishes to modify
it. \pkg{SVGAnnotation} reverse engineers and modifies \code{svg}'s
output to enhance it with animation and interactivity. Unfortunately,
once \pkg{SVGAnnotation} plots are loaded into a web browser, they are
still diffficult to modify because the resulting SVG is largely
unchanged from \code{svg}. This leaves \pkg{gridSVG} as the only
remaining option as one of its goals is to produce SVG with
identifiable output. This means that when \gridSVG{} produces a
scatter plot with a LOESS curve, we are able to easily identify the
SVG elements that the LOESS curve corresponds to.

% FIGURE: Comparing svg/SVGAnnotation output with gridSVG
% Just draw a circle with "hello, world!"
% Look at the relevant subset of the output.
% Mention how gridSVG is named and identifiable while svg/SVGAnnotation is
% largely unreadable

Relating back to the example, we should be able to load a web page
with a \gridSVG{} plot. When an HTML slider modifies the value of a
LOESS smoothing window, \R{} can give us a new \emph{piece} of a
\gridSVG{} plot which represents the new curve. The new piece can then
replace or update the existing piece of the plot. A bonus of this
approach is that we can (if desired) exploit the powerful
functionality of \proglang{JavaScript} libraries such as \pkg{D3},
which can \emph{transition} the curve to its new values. The figure
below exhibits how the pieces of software fit together.

% FIGURE SHOULD SHOW R -> gridSVG <---> browser -> D3

\textbf{INSERT PLOT}

Without being able to identify parts of a plot, it is very difficult
to perform any useful modification of a plot. \gridSVG{}'s naming of
SVG elements allows us to easily identify what it is that we are
attempting to modify. The other options, \pkg{svg} and
\pkg{SVGAnnotation} are therefore not suitable for the type of
dynamically generated graphics that we wish to produce. However, prior
to this research \gridSVG{} was not yet a usable solution that is
capable of creating these graphics. It was the solution with the
greatest potential, and this thesis largely describes how \gridSVG{}
has been improved to meet the goal of creating dynamic, interactive
and reactive statistical graphics.

\section{Existing Software}

We have discussed using \R{} to generate web pages but have glossed
over the details as to how this occurs. For a web browser to be able
to communicate to a web service that exposes functionality provided by
\R{}, it needs to communicate over a \emph{protocol}. A protocol is
simply a standard set of rules that a web browser and a web server can
use to send messages between each other, much like humans use a
language to send messages to one another. There are two protocols of
interest that are used to construct web pages, HTTP and WebSockets.

HTTP operates in a request-response model. This means that a web
browser sends a message to a web server that requests a resource
(i.e. a web page or an image). The web server responds with a message
containing the resource that the web browser requested, that the
browser can then render. The majority of the software packages that
provide a web interface to \R{} operate using HTTP.

WebSockets is a protocol which allows for bi-directional communication
between a WebSocket server and a web browser. Instead of requesting a
resource, a web browser sends a message over the WebSocket that is
received by the WebSocket server. The server needs to know how to read
the message, and it also needs to know what task the message is asking
to be performed. If both of these requirements have been fulfilled,
then the WebSocket server can send a message along the socket to the
web browser. The message could (for example) include new content that
should be included in a web page. A potentially useful feature of
WebSockets is that the server can also send a message to the browser
without the browser having explicitly requested it. An example of this
is when the server sends the browser the current time every
minute. All the browser needs to to in this instance is to know what
to do with the current time information.

The key difference between the two protocols is that HTTP requires the
browser to request a resource, while WebSockets is simply a means to
send a message without any explicit action being applied. In other
words, HTTP is analogous to sending messages in the mail whereas
WebSockets is analogous to communicating via telephone.

\subsection{Server-side Software}

There are several options available to us for allowing \R{} to act as
a webserver. Some of these options directly expose the HTTP or
WebSockets protocol from \R{}, while others allow this to occur
indirectly by acting as an intermediary between \R{} and a web
browser. We will begin by listing the possible options for generating
\R{} content for use within a web browser.

\begin{description}

\item[\pkg{Rserve}] The \pkg{Rserve} package \autocite{} allows \R{}
  to act as a background service (potentially on a remote machine)
  that is able to respond to requests over the TCP/IP protocols. This
  means that it is not directly able to be used by a web browser but
  most programming environments can communicate to this service
  because of the ubiquity of TCP/IP as a method of networking
  computers. This means that any programming environment capable of
  communicating over TCP/IP that is also able to build a web
  application can expose \R{} to a web browser. Many programming
  languages have a package or library that provides a convenient
  framework for this to occur. Unsurprisingly an web application
  framework for \R{} exists called \pkg{FastRWeb} \autocite{}. Similar
  implementations are available in the following languages:
  \proglang{Python} \autocite{}, \proglang{JavaScript} (via
  \pkg{node.js}) \autocite{}, \proglang{Java} \autocite{},
  \proglang{\CC} \autocite{}, and \proglang{PHP} \autocite{}.

\item[\pkg{rApache}] The Apache webserver is a popular HTTP server
  that is present on many servers. It is able to be extended by adding
  \emph{modules} which functionality additional to the features
  provided by the base installation. \pkg{rApache} extends Apache by
  including \R{} as a module that is capable of responding to HTTP
  requests that have been received by Apache. To make this easier,
  convenience functions have been included to make it easier to
  develop \R{} web applications with \pkg{rApache}.

\item[\pkg{Rook}] The \pkg{Rook} package builds upon \R{}'s built-in
  webserver to provide a framework for building web applications. This
  means that installing \pkg{Rook} only requires installing the
  package from CRAN, unlike \pkg{Rserve} and \pkg{rApache}.

\item[\pkg{websockets}] An implementation of the WebSockets protocol
  for \R{}. It provides little more than the means for opening up
  communication between \R{} and a web browser. Callback functions can
  be assigned to events such as receiving a message, establishing a
  connection, and closing a connection. These event handling functions
  must be created and managed by a user in both \R{} and a web
  browser.

\item[\pkg{shiny}] The \pkg{shiny} package provides a collection of
  functions for creating \emph{reactive} web applications. This builds
  upon the \pkg{websockets} package to create communication between
  \R{} and a web browser. This avoids the need to write \R{} and
  \proglang{JavaScript} code that handles behaviour relating to
  events, assuming that a web application has been constructed using
  \pkg{shiny}'s ``reactive'' functions. A feature of \pkg{shiny} is
  that it is \emph{extensible}, allowing a user to augment the
  existing functionality.

\end{description}

All of the aforementioned examples are capable of generating \R{}
graphics in response to requests from a web browser. It must be
mentioned that this list is by no means exhaustive, but does mention
the most popular options for generating web content dynamically from
\R{}.

\subsection{Client-side Software}

We know that it is possible to generate \R{} graphics from a web
server, but there are alternative options for howin the browser. We do not
necessarily require that statistical graphics are entirely generated
in \R{}. The options for statistical graphics in the browser are shown
below:

\begin{description}

\item[\R{} Static Graphics] This is the most common option where a
  static image, like a PNG or a plain SVG image is sent to a web
  browser and remains unchanged. All of the aforementioned \R{} web
  server options all provide some way of easily creating these types
  of graphics. The main reason for this is because they correspond
  directly with a built-in \R{} graphics device, whose output can can
  be sent immediately to a web browser.

\item[Animated and Interactive Graphics] As discussed earlier in this
  document, there are animated and interactive graphics that can be
  produced by packages such as \pkg{animation}, \pkg{SVGAnnotation}
  and \pkg{gridSVG} that can be delivered to a web browser.

\item[\proglang{JavaScript} Graphics] Rather than send an complete
  image to a web browser for viewing, more recently several new \R{}
  packages have emerged that have taken an alternative approach. These
  new packages that use \R{} to export a \emph{description} of a plot
  that can be rendered in a web browser by a \proglang{JavaScript}
  library. The advantages of this approach is that several
  \proglang{JavaScript} libraries give you animated and interactive
  graphics very easily. However, this does mean that the graphics
  drawn are not \R{} graphics, so we lose the facilities present in
  the \R{} graphics system.

  \proglang{JavaScript} generated graphics is an area of tremendous
  growth. Each \proglang{JavaScript} library aims to provide something
  unique, which other libraries lack. However, a common theme among
  all libraries is that it is difficult to customise the plots as much
  as we are used to with \R{}'s base or \grid{} graphics. This is
  because most libraries tend to provide a high-level function like
  \code{barchart}, but do not easily expose primitives such as line
  drawing. Unlike \grid{}, the structure of the generated plots is

  A library that has generated a lot of interest is \pkg{D3}. It
  differs from most plotting libraries because it is a high-level
  interface for modifying and generating HTML and SVG content.
  Therefore to generate a plot using \pkg{D3} requires knowing SVG and
  building up a plot using the existing SVG elements. Many libraries
  have recognised the power of modifying and generating SVG graphics
  using \pkg{D3} and have used it to create high-level plotting
  functions (e.g. to create a barchart, linechart, etc).

\end{description}

An option that has not yet been discussed is
\pkg{RFirefox}. \pkg{RFirefox} embeds \R{} within the Mozilla Firefox
web browser as an extension. It allows \R{} code to be executed in a
web page in much the same manner as \proglang{JavaScript}, including
the ability to draw \R{} plots. We omit \pkg{RFirefox} from any
consideration because we are unable to serve the \R{} generated
content over a network, nor is it easy to build upon existing tools to
extend its behaviour in order to generate new types of graphics.

\subsection{Summary}

In order to create the types of graphics we would like we can use any
\R{} server option available to us, but from now on it is assumed that
the \pkg{Rook} package is used. The primary reason for this is its
ease of use and installation. However, it must be made clear that
\emph{all} of the web server options are capable of creating
\gridSVG{} graphics and indeed pieces of \gridSVG{} graphics.

We intend for \gridSVG{} to generate these plots and the pieces of a
plot. This is because it is the only package for \R{} that is able to
not only create animated and interactive plots but also to produce
identifiable pieces of a plot. The second point is crucial because
without the ability to identify a piece of the plot it is very
difficult to modify a plot. Therefore because we can identify a piece
of the plot \gridSVG{} is suitable for creating the type of
dynamically generated graphical content that we want.

The only extra piece of software we need is a \proglang{JavaScript}
library to manipulate an image to add, modify and remove pieces of a
plot. The library that has been chosen is \pkg{D3}. This is because it
is not strictly focused on creating plots which is largely unnecessary
because \gridSVG{} will perform that task instead. \pkg{D3}'s focus on
working with SVG directly is exactly what is necessary when SVG
content has already been provided by \gridSVG{}. Additionally \pkg{D3}
also provides a powerful and performant interface for selecting pieces
of a plot and transitioning content to new states via CSS transitions
\autocite{}.

To summarise this introduction, the aim of this research was to
develop \gridSVG{} to be a bridge between the computational and
graphical facilities provided by \R{} and the interactivity that
\pkg{D3} provides. \gridSVG{} was not able to accomplish this in the
past and the rest of this thesis documents how this goal has been
achieved.

\textbf{IGNORE FROM HERE ON}

\pagebreak

The large amount of \proglang{JavaScript} libraries available for
producing plots with interactivity and dynamic properties shows that
the web browser has become a powerful platform for creating
graphics. However, these libraries by themselves do not come with the
facilities necessary for creating statistical graphics. To create
statistical graphics would require communication with a statistical
software system. Rather than creating all of our graphics within \R{},
or all of our graphics in \proglang{JavaScript}, we can create SVG
using \gridSVG{} and then manipulate it in a web browser using
\pkg{D3}. The advantage of this approach is that we are able to still
draw \R{} graphics via \gridSVG{}, but allow for features such as
transitioning using \pkg{D3}. Therefore the primary goal of this
research is to allow \gridSVG{} to act as a bridge between \R{} and
\pkg{D3}.

We will first examine a motivating example that shows the type of
graphics we want \gridSVG{} to create, and then investigate what
existing software can help to achieve the goal of implementing the
motivating example.

\section{Motivating Example}

The Visual Inference Tools system is an \R{} package developed as a
teaching aid for high school and first year university students. It
aims to demonstrate statistical concepts such as bootstrap (and other)
confidence intervals and randomisation tests. It provides a
GUI (Graphical User Interface) to allow students and teachers
to load their own data and configure the type of animation they
want. In another window, the animation can be viewed. See fig below.

%%%%
FIGURE
%%%%

The advantages of this software are that \R{} is powering all of the
statistics that are used by the software. It is also able to use
\R{}'s \grid{} graphics engine to generate all of the graphics.

The limitations of this approach are numerous.

Firstly, distributing software like this with RGtk2 is
platform-specific and therefore potentially fraught with
complications.

Unable to get ``true'' animation, only snapshots and animation via
linear interpolation.

Biggest complication: NO KNOWLEDGE OF TIME!

No declaractive user interface.

%%%%

The primary reason for the limitations is due to the R graphics engine
itself not being designed with animation in mind.

\section{Existing Software}

In order to improve upon the behaviour of VIT in a web browser we need
to use \gridSVG{} along with some other software.

There are currently a few notable packages for \R{} that do allow for
the creation of web-based interactive graphics. A description of how
these packages work follows, in order to explain why \gridSVG{} is
being improved upon.

\dots
