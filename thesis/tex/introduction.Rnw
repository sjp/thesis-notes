<<echo = FALSE, results = "hide", message = FALSE>>=
source("../knitr-settings.R")
@

\chapter{Introduction}
\label{chap:intro}

\section{What are these Graphics?}

There are numerous software packages that are capable of creating
graphs of some form. Many of these packages are also capable of
producing statistical graphics --- graphs which communicate statistical
information. The \R{} statistical software system \autocite{R13} is a
popular example of software which generates statistical graphics. The
great strength of \R{} is its wealth of statistical functions and
graphics, but only for static graphics. The proliferation of dynamic
and interactive web-based graphics using \proglang{JavaScript}
libraries such as \pkg{D3} \autocite{Bos13} shows that there is
significant interest in creating these graphics in web browsers.

In order to explain the types of graphics we wish to create, we will
first examine what \R{} can produce, and how they are used within a
web browser.

<<diagramStatic, echo = FALSE, message = FALSE, fig.height = 2, out.height = "2in", fig.width = 5, out.width = "5in", fig.cap = "An \\R{} image being included within an HTML document.">>=
simplePlot <- function() {
  pushViewport(dataViewport(xData = cars$speed, yData = cars$dist,
                            width = unit(1, "npc") - unit(1, "cm"),
                            height = unit(1, "npc") - unit(1, "cm")))
  grid.points(x = cars$speed, y = cars$dist, size = unit(0.2, "char"))
  grid.xaxis(label = FALSE)
  grid.yaxis(label = FALSE)
  popViewport()
}

grid.newpage()
l <- grid.layout(ncol = 5, widths = unit(rep(0.2, 5), "npc"))
pushViewport(viewport(layout = l))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("R", gp = gpar(fontsize = 32))
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
grid.text("png()\nsvg()", x = 0.5, y = 0.6, just = "bottom",
          gp = gpar(fontfamily = "mono"))
grid.lines(y = rep(0.5, 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 3))

pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()

popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 4))
grid.lines(y = rep(0.5, 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 5))
pushViewport(viewport(width = 0.8, height = 0.8))
grid.rect()
pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()
popViewport()
popViewport()
popViewport()
@

\autoref{fig:diagramStatic} demonstrates that \R{} can generate a
static image using its built-in graphics devices. In this example the
\code{png()} and \code{svg()} devices can produce PNG (Portable
Network Graphics) and SVG (Scalable Vector Graphics) images
respectively. These images are static, and can be included in an HTML
(Hypertext Markup Language) document using the \code{<img>} tag.

When we include images onto a web page in this manner, the effect is
largely the same as if we were treating the HTML document as a piece
of paper. Unlike a piece of paper, a useful feature of web browsers
are their ability to view content that is not fixed. A key example of
this is when we want to include animated graphics within a web
page. There are packages for \R{} that enable animation within a web
browser. We will first consider the prominent \pkg{animation} package.

The \pkg{animation} package \autocite{Xie12} uses software outside of
\R{} to construct its animations, e.g. \pkg{ImageMagick}
\autocite{Ima13} and \pkg{ffmpeg} \autocite{ffm13}. These are
additional pieces of software required to produce animations in
various formats. The general idea of \pkg{animation} is to repeatedly
draw entire plots, each of which are saved. The saved images are then
stitched together into one of the many formats that \pkg{animation}
supports. This means that \pkg{animation} can create an animated GIF
(Graphics Interchange Format) or a video out of the images that have
been saved. The resulting video or animated GIF can then be inserted
into a web page using the appropriate HTML tag (\code{<video>} and
\code{<img>} respectively).

<<diagramAnimation, echo = FALSE, message = FALSE, fig.height = 2, out.height = "2in", fig.width = 5, out.width = "5in", fig.cap = "Multiple static images generated by the \\pkg{animation} package are included in an HTML document. The images are stitched together to create an animation.">>=
library(gridSVG)

simplePlot <- function() {
  pushViewport(dataViewport(xData = cars$speed, yData = cars$dist,
                            width = unit(1, "npc") - unit(1, "cm"),
                            height = unit(1, "npc") - unit(1, "cm")))
  grid.points(x = cars$speed, y = cars$dist, size = unit(0.2, "char"))
  grid.xaxis(label = FALSE)
  grid.yaxis(label = FALSE)
  popViewport()
}

grid.newpage()
l <- grid.layout(ncol = 5, widths = unit(rep(0.2, 5), "npc"))
pushViewport(viewport(layout = l))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("R", gp = gpar(fontsize = 32))
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
grid.text("png()\nsvg()", x = 0.3, y = 0.7, just = "bottom",
          gp = gpar(fontfamily = "mono"))
grid.polyline(x = rep(c(0, 1), 3),
              y = c(0.5, 5/6, rep(0.5, 2), 0.5, 1/6),
              id = rep(1:3, each = 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 3))

pushViewport(viewport(layout = grid.layout(nrow = 3)))
for (i in 1:3) {
  pushViewport(viewport(width = 0.7, height = 0.5,
                        layout.pos.row = i, layout.pos.col = 1))
  grid.rect()
  simplePlot()
  popViewport()
}
popViewport()

popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 4))
grid.text("animation", y = 0.85, just = "bottom")
grid.polyline(x = rep(c(0, 1), 3),
              y = c(5/6, 0.6, rep(0.5, 2), 1/6, 0.4),
              id = rep(1:3, each = 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 5))
pushViewport(viewport(width = 0.8, height = 0.8))
grid.rect()
pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()
popViewport()
popViewport()
popViewport()
@

The method for using \pkg{animation} is demonstrated in
\autoref{fig:diagramAnimation}. The main idea to get across is that
several images are generated by \R{}, which are then stitched together
into an animation-capable format using \pkg{animation}. The result is
then included into a web page.

An alternative to using \pkg{animation} is to write some
\proglang{JavaScript} code to be included within an HTML document. The
\proglang{JavaScript} can recreate an animation by referring to
generated static images, and then repeatedly update the HTML to
reference the next image in the sequence. The described behaviour is
in fact already provided by \pkg{animation} through its
\code{saveHTML()} function. However, it is a ``black box'' solution
which may not be suitable for all needs. Furthermore, it does not
enable further interactivity that may be possible by writing our own
\proglang{JavaScript} and HTML code. This approach is illustrated in
\autoref{fig:diagramHTMLJS}.

<<diagramHTMLJS, echo = FALSE, message = FALSE, fig.height = 2, out.height = "2in", fig.width = 5, out.width = "5in", fig.cap = "Multiple static images can be included within an HTML document with custom \\proglang{JavaScript} used to provide interactivity and/or animation.">>=
library(gridSVG)

simplePlot <- function() {
  pushViewport(dataViewport(xData = cars$speed, yData = cars$dist,
                            width = unit(1, "npc") - unit(1, "cm"),
                            height = unit(1, "npc") - unit(1, "cm")))
  grid.points(x = cars$speed, y = cars$dist, size = unit(0.2, "char"))
  grid.xaxis(label = FALSE)
  grid.yaxis(label = FALSE)
  popViewport()
}

grid.newpage()
l <- grid.layout(ncol = 5, widths = unit(rep(0.2, 5), "npc"))
pushViewport(viewport(layout = l))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("R", gp = gpar(fontsize = 32))
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
grid.text("png()\nsvg()", x = 0.3, y = 0.7, just = "bottom",
          gp = gpar(fontfamily = "mono"))
grid.polyline(x = rep(c(0, 1), 3),
              y = c(0.5, 5/6, rep(0.5, 2), 0.5, 1/6),
              id = rep(1:3, each = 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 3))

pushViewport(viewport(layout = grid.layout(nrow = 3)))
for (i in 1:3) {
  pushViewport(viewport(width = 0.7, height = 0.5,
                        layout.pos.row = i, layout.pos.col = 1))
  grid.rect()
  simplePlot()
  popViewport()
}
popViewport()

popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 4))
grid.text("HTML/JS", y = 0.9, just = "bottom")
grid.polyline(x = rep(c(0, 1), 3),
              y = c(5/6, 0.6, rep(0.5, 2), 1/6, 0.4),
              id = rep(1:3, each = 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 5))
pushViewport(viewport(width = 0.8, height = 0.8))
grid.rect()
pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()
popViewport()
popViewport()
popViewport()
@

The \proglang{JavaScript} shown in \autoref{fig:diagramHTMLJS} can be
any \proglang{JavaScript} code that can interact with static
images. In practice the \proglang{JavaScript} code will likely be
limited to toggling which image(s) to display at a given point in
time.

A limitation in the types of images that are typically used in web
pages is that they are \emph{raster} images. This means that the image
itself is a description of the colour values encoded in a matrix of
pixels. There is no other information available so we cannot identify
or manipulate any part of a plot.

Another image format that can be used in a web browser is SVG
(Scalable Vector Graphics) \autocite{SVG11}. SVG is an XML-based
(Extensible Markup Language) \autocite{XML08} vector image format that
supports animation and interactivity (via \proglang{JavaScript}). The
fact that SVG is a vector image format means that we can scale the
image to any size and it will not lose any fidelity. The most
encouraging feature is the XML-based nature of SVG, meaning that SVG
inherits behaviour from XML.

The most interesting features of XML for creating SVG are that it is a
structured text format and there is a standard interface for
manipulating an SVG image once it has been loaded, this interface is
called the DOM (Document Object Model) \autocite{DOM04}. This means
that SVG enables (for example) the colour of a piece of text to change
after the image has been loaded in a browser.

There are two packages for \R{} which use SVG to add interactivity and
animation to plots: \pkg{SVGAnnotation} \autocite{Lan12} and
\gridSVG{} \autocite{Mur13}. The key difference between the two
packages is how they produce animated and interactive SVG
images. \pkg{SVGAnnotation} post-processes the SVG produced by \R{}'s
\code{svg()} device. It also provides functions for annotating the
post-processed SVG with animation, tooltips, and linking of two
plots. It is possible to add custom \proglang{JavaScript} to these
plots but it is difficult to write the required code because the
structure of the SVG is not clear and understandable. \gridSVG{} takes
the approach of writing its own SVG output by translating \grid{}
primitives into their SVG equivalents. Animation and interactivity is
performed by creating or annotating \grid{} graphics objects through
high-level functions.

The advantage using the \gridSVG{} approach is that it is easier to
manipulate \gridSVG{} output than the output produced by
\pkg{SVGAnnotation} as it creates its own SVG and annotates it with
\grid{} object names. However, \gridSVG{} is limited to only creating
SVG from \grid{} output, while \pkg{SVGAnnotation} is able to do this
for both the \grid{} and base graphics systems provided by \R{}.

The approach that both of these packages take to produce their plots
is illustrated by \autoref{fig:diagramSVGAnnGridSVG}.

<<diagramSVGAnnGridSVG, echo = FALSE, message = FALSE, fig.height = 2, out.height = "2in", fig.width = 5, out.width = "5in", fig.cap = "A plot generated by packages that can embed animation in an SVG image. The image is included within an HTML document, with interactivity provided by \\proglang{JavaScript}.">>=
library(gridSVG)

simplePlot <- function() {
  pushViewport(dataViewport(xData = cars$speed, yData = cars$dist,
                            width = unit(1, "npc") - unit(1, "cm"),
                            height = unit(1, "npc") - unit(1, "cm")))
  grid.points(x = cars$speed, y = cars$dist, size = unit(0.2, "char"))
  grid.xaxis(label = FALSE)
  grid.yaxis(label = FALSE)
  popViewport()
}

grid.newpage()
l <- grid.layout(ncol = 5, widths = unit(rep(0.2, 5), "npc"))
pushViewport(viewport(layout = l))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("R", gp = gpar(fontsize = 32))
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
grid.text("SVGAnnotation\ngridSVG", x = 0.3, y = 0.7, just = "bottom")
grid.lines(y = rep(0.5, 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 3))
pushViewport(viewport(width = 0.7, height = 0.7))
grid.rect()
simplePlot()
popViewport()
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 4))
grid.text("JavaScript", y = 0.7, just = "bottom")
grid.lines(y = rep(0.5, 2), arrow = arrow())
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 5))
pushViewport(viewport(width = 0.8, height = 0.8))
grid.rect()
pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()
popViewport()
popViewport()
popViewport()
@

All of the methods for getting \R{} graphics in the browser have one
feature in common --- they are all pre-generated. This means that
whenever a plot is created in \R{}, the statistical information
encoded in that image (or indeed \proglang{JavaScript} code for
\pkg{SVGAnnotation} and \pkg{gridSVG} in particular) becomes fixed. We
cannot add more statistical information to the plot without
communicating with \R{}, which is not possible with the aforementioned
solutions. To produce a plot with different information would require
\R{} to create an entirely new plot, regardless of whether the plot is
static, dynamic or interactive. What this means is that a web page
with embedded statistical graphics cannot update the images without
some way of communicating to \R{}.

There are several existing pieces of software that enable a web
browser to communicate to \R{}. The way this occurs is that a software
package can expose \R{}'s functionality by creating a web server that
can interface with a web browser using HTTP (Hypertext Transfer
Protocol). A web browser can then request resources, such as
statistical documents and graphics. In practice this means instead of
a loading a standalone HTML file on a local hard disk (or even a
remote location), \R{} generates the web page that is loaded within
the browser. Because the web page is generated as it is requested, it
does not need to be fixed.

There are many \R{} packages that are able to perform the described
functionality. Examples of these are \pkg{shiny} \autocite{RSt13},
\pkg{Rook} \autocite{Hor13} and \pkg{FastRWeb} \autocite{Urb13a}
(which requires \pkg{Rserve} \autocite{Urb13b}). The details of
existing server software will be discussed in more detail later in
this chapter. The general idea with all of these packages is that a
web browser requests a resource --- usually a web page or an image ---
which is generated by \R{}, then delivered to a web browser.

To explain why these packages are more useful than pre-generated web
pages and images, consider this example. A web page features a scatter
plot with a LOESS Curve where an HTML slider control determines the
size of the smoothing window. Each time the value of the slider
control changes we want to update the plot by replacing the existing
LOESS curve with a new one. This is simple when there is a web server
that communicates to \R{}, because we can just request an entirely new
plot which replaces the existing plot. This simple example is one
where a pre-generated HTML page is infeasible. Attempting a
pre-generated solution would require creating every possible plot,
which in this case is determined by the possible sizes of the LOESS
smoothing window. Because the value of the LOESS spanning window is a
continuous variable, this is not possible as it would require an
incredibly large amount of plots. Even if were to limit the possible
number of plots to 100, that is still a large amount of work to
pre-generate, especially if many of the plots will not be seen.

The dynamically generated solutions are able to produce a dynamic HTML
document using the process illustrated in \autoref{fig:diagramDynGen}.

<<diagramDynGen, echo = FALSE, results = "hide", fig.height = 2, out.height = "2in", fig.width = 5, out.width = "5in", fig.cap = "A change in the state of a web page allows new static images to be requested from \\R{} using one of many \\R{} web server packages.">>=
grid.newpage()
l <- grid.layout(ncol = 2, widths = unit(rep(0.5, 2), "npc"))
pushViewport(viewport(layout = l))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("R", gp = gpar(fontsize = 32))
grid.text("shiny, Rook, etc.", x = 1, y = 0.2, just = c("centre", "bottom"),
          gp = gpar(cex = 0.9))
grid.text("svg()\npng()", x = 1, y = 0.8, just = c("centre", "bottom"),
          gp = gpar(cex = 0.9, fontfamily = "mono"))
grid.lines(x = c(0.65, 1.4), y = rep(0.65, 2), arrow = arrow())
grid.lines(x = c(0.65, 1.4), y = rep(0.35, 2), arrow = arrow(ends = "first"))
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
pushViewport(viewport(x = 1 - (1.5 * 0.32), just = "left", width = 0.32, height = 0.8))
grid.rect()
pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()
popViewport()
popViewport()
popViewport()
@

The plots that are dynamically generated can be any one of the types
of plots that were discussed earlier. Typically the dynamically
generated images are simply a static plot, often the result of drawing
on the \code{png()} device. In the example that was discussed earlier,
the simple method for updating the plot that appeared on the web page
was removing the old image and inserting the newly generated image. If
the goal is to update the LOESS curve then generating an entirely new
image is not only wasteful --- because most of the plot has not
changed --- but it does not give us any way of showing \emph{how} the
curve changed.

What we aim to achieve is to be able to \emph{modify} an \R{} plot
with dynamically generated graphical content within a web
browser. What this requires is not only to be able to communicate with
\R{} to generate new content, but also to be able to identify and
modify \emph{parts} of a plot in a web page. We have already mentioned
that some \R{} packages allow us to communicate with \R{} but there
are few options available for being able to modify parts of a
plot. The only image format that is capable of the desired behaviour
is SVG. \R{}'s \code{svg()} device produces SVG that is viewable in a
web browser, but unreadable to anyone who wishes to modify
it. \pkg{SVGAnnotation} reverse engineers and modifies \code{svg()}'s
output to enhance it with animation and interactivity. Unfortunately,
once \pkg{SVGAnnotation} plots are loaded into a web browser, they are
still difficult to modify because the resulting SVG is largely
unchanged from \code{svg()}. This leaves \pkg{gridSVG} as the only
remaining option as one of its goals is to produce SVG with
identifiable output. This means that when \gridSVG{} produces a
scatter plot with a LOESS curve, we are able to easily identify the
SVG elements that the LOESS curve corresponds to.

% FIGURE: Comparing svg/SVGAnnotation output with gridSVG
% Just draw a circle with "hello, world!"
% Look at the relevant subset of the output.
% Mention how gridSVG is named and identifiable while svg/SVGAnnotation is
% largely unreadable

Relating back to the example, we should be able to load a web page
with a \gridSVG{} plot. When an HTML slider modifies the value of a
LOESS smoothing window, \R{} can give us a new \emph{piece} of a
\gridSVG{} plot which represents the new curve. The new piece can then
replace or update the existing piece of the plot. A bonus of this
approach is that we can (if desired) exploit the powerful
functionality of \proglang{JavaScript} libraries such as \pkg{D3},
which can \emph{transition} the curve to its new
values. \autoref{fig:diagramRgridSVGD3} exhibits how the pieces of
software fit together.

<<diagramRgridSVGD3, echo = FALSE, results = "hide", fig.width = 5, fig.height = 2, out.width = "5in", out.height = "2in", fig.cap = "A piece of a \\gridSVG{} image is sent to a web browser in response to a request made to an \\R{} web server instance. \\pkg{D3} handles the process of integrating the piece into the existing image.">>=
grid.newpage()
l <- grid.layout(ncol = 2, widths = unit(rep(0.5, 2), "npc"))
pushViewport(viewport(layout = l))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("R", gp = gpar(fontsize = 32))
grid.text("shiny, Rook, etc.", x = 1, y = 0.2, just = c("centre", "bottom"),
          gp = gpar(cex = 0.9))
grid.text("gridSVG", x = 1, y = 0.75, just = c("centre", "bottom"))
grid.lines(x = c(0.65, 1.4), y = rep(0.65, 2), arrow = arrow())
grid.lines(x = c(0.65, 1.4), y = rep(0.35, 2), arrow = arrow(ends = "first"))
popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
pushViewport(viewport(x = 1 - (1.5 * 0.32), just = "left", width = 0.32, height = 0.8))
grid.rect()
pushViewport(viewport(width = 0.7, height = 0.5))
grid.rect()
simplePlot()
popViewport()
popViewport()
popViewport()
popViewport()
grid.text("D3", x = 1, just = "right", gp = gpar(fontsize = 16))
@

Without the ability to identify parts of a plot, it is very difficult
to perform any useful modification of a plot. \gridSVG{}'s naming of
SVG elements allows us to easily identify what we are attempting to
modify. The other options, \pkg{svg} and \pkg{SVGAnnotation} are
therefore not suitable for the type of dynamically generated graphics
that we wish to produce. However, prior to this research \gridSVG{}
was not yet a viable solution that is capable of creating these
graphics. It was the solution with the greatest potential, and this
thesis largely describes how \gridSVG{} has been improved to meet the
goal of creating dynamic, interactive and reactive statistical
graphics.

\section{Existing Software}

We have discussed the use of \R{} as a tool for generating web pages
but have glossed over the details as to how this occurs. For a web
browser to be able to communicate to a web service that exposes
functionality provided by \R{}, it needs to communicate over a
\emph{protocol}. A protocol is simply a standard set of rules that a
web browser and a web server can use to send messages between each
other, much like humans use a language to send messages to one
another. There are two protocols of interest that are used to
construct web pages, HTTP and WebSockets.

HTTP operates in a request-response model. This means that a web
browser sends a message to a web server that requests a resource
(e.g. a web page or an image). The web server responds with a message
containing the resource that the web browser requested, that the
browser can then render. The majority of the software packages that
provide a web interface to \R{} operate using HTTP.

WebSockets is a protocol which allows for bi-directional communication
between a WebSocket server and a web browser. Instead of requesting a
resource, a web browser sends a message over the WebSocket which is
received by the WebSocket server. The server needs to know how to read
the message, and it also needs to know what task the message is asking
to be performed. If both of these requirements are fulfilled, then the
WebSocket server can send a message along the socket to the web
browser. The message could (for example) include new content that
should be included in a web page. A potentially useful feature of
WebSockets is that the server can also send a message to the browser
without the browser having to explicitly request it. An example of
this is when the server sends the browser the current time every
minute. All the browser needs to do in this instance is to know what
to do with the current time information.

The key difference between the two protocols is that HTTP requires the
browser to request a resource, while WebSockets is simply a means to
send a message without any explicit action being applied. In other
words, HTTP is analogous to sending messages in the mail whereas
WebSockets is analogous to communicating via telephone.

\subsection{Server-side Software}

There are several options available to us for enabling \R{} to act as
a web server. Some of these options directly expose the HTTP or
WebSockets protocol from \R{}, while others allow this to occur
indirectly by acting as an intermediary between \R{} and a web
browser. We will begin by listing the possible options for generating
\R{} content for use within a web browser.

\begin{description}

\item[\pkg{Rserve}] The \pkg{Rserve} package \autocite{Urb13b} allows
  \R{} to act as a background service (potentially on a remote
  machine) that is able to respond to requests over the TCP/IP
  protocols. This means that it is not directly able to be used by a
  web browser. However, most programming environments can communicate
  to this service because of the ubiquity of TCP/IP as a method of
  networking computers. This means that any programming environment
  capable of communicating over TCP/IP that is also able to build a
  web application can expose \R{} to a web browser. Many programming
  languages have a package or library that provides a convenient
  framework for this to occur. Unsurprisingly, a web application
  framework for \R{} exists called \pkg{FastRWeb}
  \autocite{Urb13a}. Similar implementations are available in the
  following languages: \proglang{Python} \autocite{pyr13},
  \proglang{JavaScript} (via \pkg{node.js}) \autocite{rnode13},
  \autocite{noderio13}, \proglang{Java} \autocite{Urb13c},
  \proglang{\CC} \autocite{Urb13b}, and \proglang{PHP}
  \autocite{Tur13}.

\item[\pkg{rApache}] The Apache web server is a popular HTTP server
  that is present on many servers. It is able to be extended by adding
  \emph{modules} which functionality additional to the features
  provided by the base installation. \pkg{rApache} \autocite{Hor12}
  extends Apache by including \R{} as a module that is capable of
  responding to HTTP requests that have been received by Apache. To
  make this easier, convenience functions have been included to make
  it easier to develop \R{} web applications with \pkg{rApache}.

\item[\pkg{Rook}] The \pkg{Rook} package \autocite{Hor13} builds upon
  \R{}'s built-in web server to provide a framework for building web
  applications. This means that installing \pkg{Rook} only requires
  installing the package from CRAN, unlike \pkg{Rserve} and
  \pkg{rApache} which are more complicated to install.

\item[\pkg{websockets}] An implementation of the WebSockets protocol
  for \R{}. The \pkg{websockets} package \autocite{Lew12} provides little
  more than the means for opening up communication between \R{} and a
  web browser. Callback functions can be assigned to events such as
  receiving a message, establishing a connection, and closing a
  connection. These event handling functions must be created and
  managed by a user in both \R{} and a web browser.

\item[\pkg{shiny}] The \pkg{shiny} package \autocite{RSt13} provides a
  collection of functions for creating \emph{reactive} web
  applications. This builds upon the \pkg{websockets} package to
  create communication between \R{} and a web browser. This avoids the
  need to write \R{} and \proglang{JavaScript} code that handles
  behaviour relating to events, assuming that a web application has
  been constructed using \pkg{shiny}'s ``reactive'' functions. A
  feature of \pkg{shiny} is that it is \emph{extensible}, allowing a
  user to augment the existing functionality.

\end{description}

All of the aforementioned examples are capable of generating \R{}
graphics in response to requests from a web browser. It must be
mentioned that this list is by no means exhaustive, but does mention
the most popular options for generating web content dynamically from
\R{}.

\subsection{Client-side Software}

We know that it is possible to generate \R{} graphics from a web
server, but there are alternative options for displaying plots in a
web browser. We do not necessarily require that statistical graphics
are entirely generated in \R{}. The options for statistical graphics
in the browser are shown below:

\begin{description}

\item[\R{} Static Graphics] This is the most common option where a
  static image, like a PNG or a plain SVG image is sent to a web
  browser and remains unchanged. All of the aforementioned \R{} web
  server options provide some way of easily creating these types of
  graphics. The main reason for this is because they correspond
  directly with a built-in \R{} graphics device, whose output can can
  be sent immediately to a web browser.

\item[Animated and Interactive Graphics] As discussed earlier in this
  chapter, there are animated and interactive graphics that can be
  produced by packages such as \pkg{animation}, \pkg{SVGAnnotation}
  and \pkg{gridSVG} which can be delivered to a web browser.

\item[\proglang{JavaScript} Graphics] There are several new \R{}
  packages that have emerged recently. These packages have taken an
  alternative approach where instead of sending a complete image to a
  web browser for viewing, \R{} is used to export a \emph{description}
  of a plot which can then be rendered in a web browser by a
  \proglang{JavaScript} library. Examples of these packages are
  \pkg{rHighcharts} \autocite{Rei13a}, \pkg{rVega} \autocite{Rei13b},
  \pkg{rCharts} \autocite{Vai13a}, and \pkg{rNVD3}
  \autocite{Vai13b}. The advantage of this approach is that several
  \proglang{JavaScript} libraries give you animated and interactive
  graphics very easily. However, this means that the drawn graphics
  are not \R{} graphics, so we lose the facilities present in the \R{}
  graphics system. Another alternative is to use \R{} to send data to
  the browser, where \proglang{JavaScript} code describes and draws
  the desired plot. Performing both the description and rendering of
  graphics in a browser may be desirable if a user is fluent in
  \proglang{JavaScript} but the trade-off is that the benefits of the
  \R{} graphics system are lost.

  \proglang{JavaScript} generated graphics is an area of tremendous
  growth. Each \proglang{JavaScript} library aims to provide something
  unique, which other libraries lack. However, a common theme among
  all libraries is that it is difficult to customise the plots as much
  as we are used to with \R{}'s base or \grid{} graphics. This is
  because most libraries tend to provide a high-level function like
  \code{barchart()}, but do not easily expose primitives such as line
  drawing. Unlike \grid{}, the structure of the generated plots is not
  always clear and there is no concept of a display
  list. Consequently, it is difficult to modify a plot generated by a
  \pkg{JavaScript} library.

  A library that has generated a lot of interest is \pkg{D3}. It
  differs from most plotting libraries because it is a high-level
  interface for modifying and generating HTML and SVG content.
  Therefore to generate a plot using \pkg{D3} requires knowing SVG and
  building up a plot using the existing SVG elements. Many libraries
  have recognised the power of modifying and generating SVG graphics
  using \pkg{D3} and have used it to create high-level plotting
  functions (e.g. to create a barchart, linechart, etc).

\end{description}

An option that has not yet been discussed is \pkg{RFirefox}
\autocite{Bec13}. \pkg{RFirefox} embeds \R{} within the Mozilla
Firefox web browser as an extension. It allows \R{} code to be
executed in a web page in much the same manner as
\proglang{JavaScript}, including the ability to draw \R{} plots. We
omit \pkg{RFirefox} from any consideration because we are unable to
serve the \R{} generated content over a network, nor is it easy to
build upon existing tools to extend its behaviour in order to generate
new types of graphics.

\section{Summary}

In order to create the types of graphics we desire, we can use any
\R{} server option available to us. For the purposes of this thesis it
is assumed that the \pkg{Rook} package is used. The primary reason for
this is its ease of use and installation. However, it must be made
clear that \emph{all} of the web server options are capable of
creating \gridSVG{} graphics and indeed pieces of \gridSVG{} graphics.

We intend for \gridSVG{} to generate these plots and the pieces of a
plot. This is because it is the only package for \R{} that is able to
not only create animated and interactive plots but also to produce
identifiable pieces of a plot. The second point is crucial because
without the ability to identify a piece of the plot it is very
difficult to modify a plot. Therefore because we can identify a piece
of the plot \gridSVG{} is suitable for creating the type of
dynamically generated graphical content that we want.

The only extra piece of software we need is a \proglang{JavaScript}
library to manipulate an image to add, modify and remove pieces of a
plot. The library that has been chosen is \pkg{D3}. This is because it
is not strictly focused on creating plots which is largely unnecessary
because \gridSVG{} will perform that task instead. \pkg{D3}'s focus on
working with SVG directly is exactly what is necessary when SVG
content has already been provided by \gridSVG{}. Additionally \pkg{D3}
also provides a powerful and performant interface for selecting pieces
of a plot and transitioning content to new states via CSS transitions
\autocite{CSSTr13}.

To summarise this introduction, the aim of this research was to
develop \gridSVG{} to be a bridge between the computational and
graphical facilities provided by \R{} and the interactivity that
\pkg{D3} provides. \gridSVG{} was not able to accomplish this in the
past, but it represented the best opportunity for further development,
and the rest of this thesis documents how this goal has been achieved.
