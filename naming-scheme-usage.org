#+TITLE: Uses of naming schemes in alternative systems

While there are more details below about each of the implementations,
many were ignored. This is primarily because many existing graphics
systems draw to a canvas or a raster image. While an HTML ~<canvas>~
is capable of interactivity, this is maintained entirely in JS
and *not* in the image itself (because a ~<canvas>~ is just a
collection of pixels). In other words, we require that names
are *exposed* to the user for extensibility.

Overall, seems to be clear that IDs are used only when strictly
necessary (i.e. XAML, QML, D3) and *not* to label content as part of
some pre-existing naming scheme. In the case of D3 this is purely for
convenience. The only naming schemes that have been applied to all
"grobs" are useless (see plot2svg).

In order to have some structure imposed on the names of the SVG
output, we need to have a naming scheme present. We see this in
~lattice~, and pieces of it in ~ggplot2~, but is non-existant in
~hexbin~. In the case of ~hexbin~, although there are names, they are
completely lacking in any description (auto-generated) so they are of
no use.

* plot2svg (Matlab SVG graphics device)

http://www.mathworks.com/matlabcentral/fileexchange/7401-scalable-vector-graphics-svg-export-of-figures

This is a system similar to gridSVG in that it is able to produce
structured SVG output based on an existing graphics engine. However,
it differs markedly in the names applied to its output. This is
primarily because Matlab does not name each graphical object in its
plot like grid does. As a result, although each piece of the plot is
given an SVG ID, it is largely useless because the ID is of the form
"ID000001", etc.

Although the IDs are guaranteed to be unique, they are *not* useful
because we have no way of knowing what any given ID refers to, or how
any piece of the plot is mapped to SVG.

* XAML (Extensible Application Markup Language)

A declarative means of describing a GUI using XML. It is able to be
used in .NET Framework 3.0+ and is easily created within Visual Studio
2008+.

Much like we describe an image in SVG with XML, XAML does the same
thing to describe how an application should look and behave. It is
important to note the ~Name~ parameter, because this is equivalent to
SVG's ID attribute. It allows us to give a descriptive name for an
element in the application (which may not necessarily be
visible). These names *must* be unique but are not required to be
present on an element.

They are particularly useful because these are the same names that the
code driving the application uses to perform anything interactive. The
uniqueness is enforced by automatically generating names in Visual
Studio (i.e. first button is button1, second, button2, etc). However,
this demonstrates that all descriptive names *must* be generated by
the user and is not part of the XAML/WPF system itself.

An example of XAML is shown below:

:
:
:
:
:
:
:

* QML (Qt Modelling Language)

QML is a JavaScript-like language used to declaratively describe a
GUI. Each element of the plot (e.g. a ~Rectangle~) can (though not
required) be given an ~id~ attribute. This ID is equivalent to the
~id~ attribute that we use within SVG. This is particularly important
because objects can refer to attributes of other objects. As an
example:

: A {
:     ...
:     width: B.width / 2
:     ...
: }

Again though, the naming scheme has to be enforced by the user. The
naming scheme allows a developer to create interactivity and actions
for elements described in QML easily by name.

See example output below:

: Item {
:     Rectangle {
:         id: myRect
:         width: 100
:         height: 100
:     }
:     Rectangle {
:         width: myRect.width
:         height: 200
:     }
: }

* GtkBuilder/Glade

See http://git.gnome.org/browse/glade/tree/src/glade.glade

Again, like XAML, this format uses XML to describe what a GUI should
look like. It uses the ~id~ attribute to name components of a GUI. The
XML itself isn't particularly descriptive however, at least in terms
of the names of each of the elements.

* DocBook

DocBook can make use of a naming scheme to be able to apply (for
example) links within documents and to other documents/resources.

This is required because each link that needs to be made (within a
document), needs to be given an ~xml:id~ attribute with a unique
name. If this attribute is not present on an element then a ~link~ or
~xref~ element may not be able to refer to it.

* D3

No naming scheme besides the use of SVG ID attributes. Required to add
them in yourself as required for your needs.

* Highcharts

Uses SVG classes to describe what type of thing is being drawn but
does not go to the level of detail of adding IDs to uniquely identify
anything. So while we know that we are drawing an axis for example, we
may not know *which* axis it is that we're referring to.

* Google Charts

No classes or IDs, i.e. no naming scheme whatsoever. Can only refer to
content by its SVG structure, otherwise out of luck.

* Raphael

No classes or IDs, again, like Google Charts, no naming scheme and
have to refer to the structure and content of the resulting SVG to
work out how to refer to anything.
